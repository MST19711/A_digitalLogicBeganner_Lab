# 数字逻辑与计算机组成实验 第六次实验 VGA实验 实验报告
> 211502008 李诚希
>
> chengxili@smail.nju.edu.cn

该试验中实现了一个硬件控制台，并在控制台上实现一些简单的功能。

## VGA显示

### 整体设计

编写一个VGA控制器，接收VGA时钟，输出当前输出的像素的位置。然后每个子模块都有一个接口输入VGA像素位置输出像素颜色。模块再接受像素颜色输入并将其输出到VGA输出接口。VGA时钟使用IP核精确分频得到

### 模块设计

使用一个模块计算像素的扫描顺序以及是否在可显示范围内，同时接受颜色信息并输出到VGA输出接口：

``` verilog
module VGASim(
    output [31:0] ram_addr,
    input CLK,        //ϵͳʱ���ź�
    input  BTNC,           // ��λ�ź�
    output [3:0] VGA_R,    //��ɫ�ź�ֵ
    output [3:0] VGA_G,    //��ɫ�ź�ֵ
    output [3:0] VGA_B,     //��ɫ�ź�ֵ
    output  VGA_HS,         //��ͬ���ź�
    output  VGA_VS,          //֡ͬ���ź�
    output VALID,
    input [11:0] vramd_read
 );
wire [11:0] vga_data;
wire valid;
wire [11:0] h_addr;
wire [11:0] v_addr;
assign VALID = valid;
assign ram_addr = (v_addr * 640) + {20'd0, h_addr};
assign vga_data = vramd_read;
VGACtrl vgactrl(.pix_x(h_addr),.pix_y(v_addr),.hsync(VGA_HS),.vsync(VGA_VS),.pix_valid(valid),.pix_clk(CLK),.pix_rst(BTNC));
assign VGA_R = (valid == 1'b1) ? vga_data[11:8] : 4'b0000;
assign VGA_G = (valid == 1'b1) ? vga_data[7:4] : 4'b0000;
assign VGA_B = (valid == 1'b1) ? vga_data[3:0] : 4'b0000;
```

使用一个模块根据时钟信号生成像素位置以及是否为可显示：

``` verilog
module VGACtrl(
    input   wire            pix_clk,     //����ʱ���ź�
    input   wire            pix_rst,     //��λ�ź�
    output  wire  [11:0]    pix_x,      //�����ڿ���ʾ�����е�ˮƽλ��
    output  wire  [11:0]    pix_y,      //�����ڿ���ʾ�����еĴ�ֱλ��
    output  wire            hsync,      //ˮƽͬ���ź�
    output  wire            vsync,      //��ֱͬ���ź�
    output wire             pix_valid    //�����ڿ���ʾ�����־
);
//hsync1688 	1280��1024@60Hz
   parameter    H_Sync_Width = 96;
   parameter    H_Back_Porche = 48;
   parameter    H_Active_Pixels = 640;
   parameter    H_Front_Porch = 16;
   parameter    H_Totals = 800;
 //vsync1066
   parameter    V_Sync_Width = 2;
   parameter    V_Back_Porche = 33;
   parameter    V_Active_Pixels = 480;
   parameter    V_Front_Porch = 10;
   parameter    V_Totals = 525;
   reg [11:0]   cnt_h       ;
   reg [11:0]   cnt_v       ;
   wire         rgb_valid   ;
  //�͵�ƽ��Ч   
/* //real
assign hsync = ((cnt_h >= H_Sync_Width)) ? 1'b0 : 1'b1;  //����ˮƽͬ�����أ�hsync=0
assign vsync = ((cnt_v >= V_Sync_Width)) ? 1'b0 : 1'b1;  //����֡ͬ�����أ�vsync=0
*/ // for NVBOARD
assign hsync = (cnt_h > H_Sync_Width);  //����ˮƽͬ�����أ�hsync=1
assign vsync = (cnt_v > V_Sync_Width);  //����֡ͬ�����أ�vsync=1
//cnt_h��cnt_v����λ�ü���
always@(posedge pix_clk) begin
         if (pix_rst) begin
            cnt_h <= 0;
            cnt_v <= 0;
        end
       if (cnt_h == (H_Totals-1)) begin               // �����ؽ���
            cnt_h <= 0;
            cnt_v <= (cnt_v == (V_Totals-1)) ? 0 : cnt_v + 1;  // ֡���ؽ���
          end 
        else begin
               cnt_h <= cnt_h + 1;
            end
 end
//pix_valid=1����ʾ���ش�����Ч��ʾ����
//assign h_valid = (x_cnt > h_active) & (x_cnt <= h_backporch);
//assign v_valid = (y_cnt > v_active) & (y_cnt <= v_backporch);
//assign valid = h_valid & v_valid;

 /*// for real VGA
 assign  pix_valid = (((cnt_h >= H_Sync_Width + H_Back_Porche)
                    && (cnt_h <= H_Totals - H_Front_Porch))
                    &&((cnt_v >= V_Sync_Width + V_Back_Porche)
                    && (cnt_v <= V_Totals - V_Front_Porch)))
                    ? 1'b1 : 1'b0;
 */
 // for NVBoard
 assign  pix_valid = (((cnt_h > H_Sync_Width + H_Back_Porche)
                    && (cnt_h <= H_Totals - H_Front_Porch))
                    &&((cnt_v > V_Sync_Width + V_Back_Porche)
                    && (cnt_v <= V_Totals - V_Front_Porch)))
                    ? 1'b1 : 1'b0;
//Hsync,Vsync active�����������ڿ���ʾ�����λ��
   assign pix_x = (pix_valid==1) ? (cnt_h - (H_Sync_Width + H_Back_Porche)):12'h0;
   assign pix_y = (pix_valid==1) ? (cnt_v - (V_Sync_Width + V_Back_Porche)):12'h0;
endmodule
```

## 键盘

### 整体设计

使用上一个实验的键盘模块并进行一些改进，令其只输出一些最新输入的ascii字符和一些键盘状态。

### 模块设计

`KeyboardSim`模块首先通过时钟分频器将100MHz的时钟信号分频成50MHz。然后，`KeyBoardReceiver`子模块接收PS2键盘的时钟和数据信号，并在准备好时输出键盘扫描码。接下来，主模块处理这些扫描码，管理CapsLock、NumLock、Shift、Ctrl和Alt等状态，并将扫描码转换为ASCII码。最后，模块输出ASCII码和一系列键盘状态信号，包括方向键和功能键的状态。

此代码还包含一个计数器，用于跟踪接收到的扫描码数量，并在特定条件下更新ASCII码和键盘状态信号。例如，当检测到CapsLock或Shift键的状态改变时，它会相应地转换字母的大小写。

```verilog 

module KeyboardSim(
    input CLK100MHZ,   //ϵͳʱ���ź�
    input PS2_CLK,    //���Լ��̵�ʱ���ź�
    input PS2_DATA,  //���Լ��̵Ĵ�������λ
    input BTNC,      //Reset
    output [7:0] ascii_out,
    output [10:0] kb_sig,// 10:esc, 9:backspace, 8:u, 7:d, 6:l, 5:r
    output ascii_available
    );
    
// Add your code here
    wire [31:0] keycode;
    wire ready;
    reg [31:0] counter = 32'd0;
    reg CLK50MHZ=0;    
    always @(posedge(CLK100MHZ))begin
        CLK50MHZ<=~CLK50MHZ;
    end
    KeyBoardReceiver keyboard_0(
        .keycodeout(keycode),           //���յ�����4������ɨ����
        .ready(ready),                     //���ݾ�����־λ
        .clk(CLK50MHZ),                        //ϵͳʱ�� 
        .kb_clk(PS2_CLK),                    //���� ʱ���ź�
        .kb_data(PS2_DATA)                    //���� ��������
    );
    
    reg testout = 0;
    reg [7:0] now_ascii;
    wire [7:0] Nascii_w;
    assign Nascii_w = now_ascii;
    assign ascii_out = now_ascii;
    wire [7:0]ascii_temp;
    // verilator lint_off INITIALDLY
    reg CapsLock = 0, NumLock = 0, Shift = 0, Ctrl = 0, Alt = 0;
    reg uR = 0, dR = 0, lR = 0, rR = 0;
    reg bsR = 0, escR = 0;
    // verilator lint_on INITIALDLY
    reg [7:0] last_SC, this_SC;
    kbcode2ascii k2a_0(
        .asciicode(ascii_temp),
        .kbcode(this_SC)
    );
    assign kb_sig[0] = CapsLock;
    assign kb_sig[1] = NumLock;
    assign kb_sig[2] = Shift;
    assign kb_sig[3] = Ctrl;
    assign kb_sig[4] = Alt;
    assign kb_sig[5] = rR;
    assign kb_sig[6] = lR;
    assign kb_sig[7] = dR;
    assign kb_sig[8] = uR;
    assign kb_sig[9] = bsR;
    assign kb_sig[10] = escR;
    // seg7decimal sevenSeg (.x({counter[7:0], last_SC, this_SC, Nascii_w}),.clk(CLK100MHZ),.seg(SEG[6:0]),.an(AN[7:0]),.dp(DP) );
    //{counter[7:0], last_SC, this_SC, Nascii_w}
    reg ascii_available_R = 0;
    assign ascii_available = ascii_available_R;
    reg [31:0] snapshot = 0;
    reg next_available = 0;
    always @(posedge CLK100MHZ) begin
        if(uR == 1)begin
            uR <= 0;
        end
        if(dR == 1)begin
            dR <= 0;
        end
        if(lR == 1)begin
            lR <= 0;
        end
        if(rR == 1)begin
            rR <= 0;
        end
        if(bsR == 1)begin
            bsR <= 0;
        end
        if(escR == 1)begin
            escR <= 0;
        end

        if(next_available == 1)begin
            ascii_available_R <= 1;
            next_available <= 0;
        end else begin
            ascii_available_R <= 0;
            next_available <= 0;
        end
        if(snapshot != keycode)begin
            snapshot <= keycode;
            if(keycode[15:0] == 16'hE075)begin
                uR <= 1;
            end
            if(keycode[15:0] == 16'hE072)begin
                dR <= 1;
            end
            if(keycode[15:0] == 16'hE06B)begin
                rR <= 1;
            end
            if(keycode[15:0] == 16'hE074)begin
                lR <= 1;
            end
            if(keycode[15:8] != 8'hf0)begin        
                    if(keycode[7:0] == 8'h58)   CapsLock <= ~CapsLock;
                    else if(keycode[7:0] == 8'h77)   NumLock <= ~NumLock;
                    else if(keycode[7:0] == 8'h12)   Shift <= 1;
                    else if(keycode[7:0] == 8'h59)   Shift <= 1;
                    else if(keycode[7:0] == 8'h14)   Ctrl <= 1;
                    else if(keycode[7:0] == 8'h11)   Alt <= 1;
                    else if(keycode[7:0] == 8'h66)   bsR <= 1;
                    else if(keycode[7:0] == 8'h76)   escR <= 1;
                    else if((keycode[7:0] != 8'hf0) & (keycode[15:8] != 8'hE0) & (keycode[7:0] != 8'hE0))begin
                        next_available <= 1;
                        //$display("receive %x", keycode[7:0]);
                    end
                    if(keycode[7:0] != 8'hf0)begin
                        last_SC <= this_SC;
                        this_SC <= keycode[7:0];
                    end
                    counter <= counter + 1;
            end else begin
                if(keycode[7:0] == 8'h12)   Shift <= 0;
                if(keycode[7:0] == 8'h59)   Shift <= 0;
                if(keycode[7:0] == 8'h14)   Ctrl <= 0;
                if(keycode[7:0] == 8'h11)   Alt <= 0;
                if(keycode[7:0] == 8'h66)   bsR <= 0;
                if(keycode[7:0] == 8'h76)   escR <= 1;
                counter <= counter - 1;
            end
        end
        if(CapsLock ^ Shift == 1)begin
            testout <= 1;
            /*
            python3
                 for i in list(string.ascii_lowercase):
                     print("else if(ascii_temp == 8'd{})  now_ascii <= 8'd{};".format(str(ord(i)), str(ord(i) + ord('A') - ord('a'))))
            */
                if(ascii_temp == 8'h61)  now_ascii <= 8'd65;
                else if(ascii_temp == 8'd98)  now_ascii <= 8'd66;
                       else if(ascii_temp == 8'd99)  now_ascii <= 8'd67;
                       else if(ascii_temp == 8'd100)  now_ascii <= 8'd68;
                       else if(ascii_temp == 8'd101)  now_ascii <= 8'd69;
                       else if(ascii_temp == 8'd102)  now_ascii <= 8'd70;
                       else if(ascii_temp == 8'd103)  now_ascii <= 8'd71;
                       else if(ascii_temp == 8'd104)  now_ascii <= 8'd72;
                       else if(ascii_temp == 8'd105)  now_ascii <= 8'd73;
                       else if(ascii_temp == 8'd106)  now_ascii <= 8'd74;
                       else if(ascii_temp == 8'd107)  now_ascii <= 8'd75;
                       else if(ascii_temp == 8'd108)  now_ascii <= 8'd76;
                       else if(ascii_temp == 8'd109)  now_ascii <= 8'd77;
                       else if(ascii_temp == 8'd110)  now_ascii <= 8'd78;
                       else if(ascii_temp == 8'd111)  now_ascii <= 8'd79;
                       else if(ascii_temp == 8'd112)  now_ascii <= 8'd80;
                       else if(ascii_temp == 8'd113)  now_ascii <= 8'd81;
                       else if(ascii_temp == 8'd114)  now_ascii <= 8'd82;
                       else if(ascii_temp == 8'd115)  now_ascii <= 8'd83;
                       else if(ascii_temp == 8'd116)  now_ascii <= 8'd84;
                       else if(ascii_temp == 8'd117)  now_ascii <= 8'd85;
                       else if(ascii_temp == 8'd118)  now_ascii <= 8'd86;
                       else if(ascii_temp == 8'd119)  now_ascii <= 8'd87;
                       else if(ascii_temp == 8'd120)  now_ascii <= 8'd88;
                       else if(ascii_temp == 8'd121)  now_ascii <= 8'd89;
                       else if(ascii_temp == 8'd122)  now_ascii <= 8'd90;
                       else if(ascii_temp == 8'd61)  now_ascii <= 8'd43;
                       else if(ascii_temp == 8'd45)  now_ascii <= 8'd95;
                       else if(ascii_temp == 8'd48)  now_ascii <= 8'd41;
                       else if(ascii_temp == 8'd57)  now_ascii <= 8'd40;
                       else if(ascii_temp == 8'd56)  now_ascii <= 8'd42;
                       else now_ascii <= ascii_temp;
            end else begin
                now_ascii <= ascii_temp;
                testout <= 0;
            end
    end
endmodule
```

该模块中定义了两个Verilog模块，`KeyBoardReceiver`和`debouncer`，用于处理PS2键盘输入。

- **`KeyBoardReceiver`模块**：接收键盘扫描码并输出32位的`keycodeout`。它使用一个状态机来跟踪接收到的数据位，并在接收到完整的扫描码后设置`ready`标志。
- **`debouncer`模块**：用于消除由于机械或电气噪声引起的键盘信号的抖动。它等待连续20个相同的信号样本，然后才将该信号视为稳定的，并输出到`O0`和`O1`。

在`KeyBoardReceiver`中，`always`块在`kb_clk`的下降沿触发，按顺序接收数据位，并在接收到完整的8位数据后，通过`flag`信号触发另一个`always`块，该块负责更新`keycode`寄存器和`readyflag`。如果检测到重复的数据或`last_up`不为零（表示之前有按键释放），则会更新`keycode`并设置`readyflag`。

```verilog
`define NVBoard

module KeyBoardReceiver(
        output [31:0] keycodeout,           //���յ�����4������ɨ����
        output ready,                     //���ݾ�����־λ
        input clk,                        //ϵͳʱ�� 
        input kb_clk,                    //���� ʱ���ź�
        input kb_data                    //���� ��������
    );
    wire kclkf, kdataf;
    reg [7:0]datacur;              //��ǰɨ����
    reg [7:0]dataprev;            //��һ��ɨ����
    reg [3:0]cnt;                //�յ�����λ��
    reg [31:0]keycode;            //ɨ����
    reg flag;                     //����1֡����
    reg readyflag = 0;
//    reg error;                   //�����־�?
    initial begin                 //��ʼ��
        keycode[7:0] = 8'b00000000;
        cnt = 4'b0000;
    end

`ifdef NVBoard
    // It is for NVBoard, in FPGA please use debouncer
    assign kclkf = kb_clk;
    assign kdataf = kb_data;
`else
    debouncer debounce( .clk(clk), .I0(kb_clk), .I1(kb_data), .O0(kclkf), .O1(kdataf));
`endif
    
    always@(negedge(kclkf))begin
     case(cnt)
            0:  ;//readyflag<=1'b0;                       //��ʼλ
            1:begin datacur[0]<=kdataf; end
            2:datacur[1]<=kdataf;
            3:datacur[2]<=kdataf;
            4:datacur[3]<=kdataf;
            5:datacur[4]<=kdataf;
            6:datacur[5]<=kdataf;
            7:datacur[6]<=kdataf;
            8:datacur[7]<=kdataf;
            9:flag<=1'b1;         //�ѽ���8λ��Ч����
            10:flag<=1'b0;       //����λ
          endcase
        if(cnt<=9) cnt<=cnt+1;
        else if(cnt==10)  cnt<=0;
    end
    reg [3:0]last_up = 0;
    always @(posedge flag)begin
        if (dataprev!=datacur | last_up != 0)begin           //ȥ���ظ���������
            if(last_up != 0 && datacur != 8'hF0)    last_up <= last_up - 1;
            keycode[31:24]<=keycode[23:16];
            keycode[23:16]<=keycode[15:8];
            keycode[15:8]<=dataprev;
            keycode[7:0]<=datacur;
            dataprev<=datacur;
            readyflag<=1'b1;              //���ݾ�����־λ��1
            if(datacur == 8'hF0)begin
                last_up <= 2;
            end 
        end else begin
             readyflag <= 1'b0;
        end
    end
    assign keycodeout = keycode;
    assign ready = readyflag; //readyflag;    
endmodule

module debouncer(
    input clk,
    input I0,
    input I1,
    output reg O0,
    output reg O1
    );
    reg [4:0]cnt0, cnt1;
    reg Iv0=0,Iv1=0;
    reg out0, out1;
    always@(posedge(clk))begin
    if (I0==Iv0)begin
        if (cnt0==19) O0<=I0;   //���յ�20����ͬ����
        else cnt0<=cnt0+1;
      end
    else begin
        cnt0<=5'b00000;
        Iv0<=I0;
    end
    if (I1==Iv1)begin
            if (cnt1==19) O1<=I1;  //���յ�20����ͬ����
            else cnt1<=cnt1+1;
          end
        else begin
            cnt1<=5'b00000;
            Iv1<=I1;
        end
    end
endmodule
```

这是一个将键盘扫描码转换为ascii的模块。

```verilog
module kbcode2ascii(
      output[7:0] asciicode,
      input [7:0] kbcode
);
    reg [7:0] kb_mem[255:0];
    initial
    begin
    /*
    python3
    for i in range(0, 255):
        inpu
    */
     //$readmemh("D:\Documents\GitHub\digitalLogic_Lab\digital_logic_exp\lab5\scancode.txt", kb_mem, 0, 255);  //�޸�scancode.txt���·��
        kb_mem[0] = 8'h00;
        kb_mem[1] = 8'h00;
        kb_mem[2] = 8'h00;
        kb_mem[3] = 8'h00;
        kb_mem[4] = 8'h00;
        kb_mem[5] = 8'h00;
        kb_mem[6] = 8'h00;
        kb_mem[7] = 8'h00;
        kb_mem[8] = 8'h00;
        kb_mem[9] = 8'h00;
        kb_mem[10] = 8'h00;
        kb_mem[11] = 8'h00;
        kb_mem[12] = 8'h00;
        kb_mem[13] = 8'h20;
        kb_mem[14] = 8'h60;
        kb_mem[15] = 8'h00;
        kb_mem[16] = 8'h00;
        kb_mem[17] = 8'h00;
        kb_mem[18] = 8'h00;
        kb_mem[19] = 8'h00;
        kb_mem[20] = 8'h00;
        kb_mem[21] = 8'h71;
        kb_mem[22] = 8'h31;
        kb_mem[23] = 8'h00;
        kb_mem[24] = 8'h00;
        kb_mem[25] = 8'h00;
        kb_mem[26] = 8'h7A;
        kb_mem[27] = 8'h73;
        kb_mem[28] = 8'h61;
        kb_mem[29] = 8'h77;
        kb_mem[30] = 8'h32;
        kb_mem[31] = 8'h00;
        kb_mem[32] = 8'h00;
        kb_mem[33] = 8'h63;
        kb_mem[34] = 8'h78;
        kb_mem[35] = 8'h64;
        kb_mem[36] = 8'h65;
        kb_mem[37] = 8'h34;
        kb_mem[38] = 8'h33;
        kb_mem[39] = 8'h00;
        kb_mem[40] = 8'h00;
        kb_mem[41] = 8'h20;
        kb_mem[42] = 8'h76;
        kb_mem[43] = 8'h66;
        kb_mem[44] = 8'h74;
        kb_mem[45] = 8'h72;
        kb_mem[46] = 8'h35;
        kb_mem[47] = 8'h00;
        kb_mem[48] = 8'h00;
        kb_mem[49] = 8'h6E;
        kb_mem[50] = 8'h62;
        kb_mem[51] = 8'h68;
        kb_mem[52] = 8'h67;
        kb_mem[53] = 8'h79;
        kb_mem[54] = 8'h36;
        kb_mem[55] = 8'h00;
        kb_mem[56] = 8'h00;
        kb_mem[57] = 8'h00;
        kb_mem[58] = 8'h6D;
        kb_mem[59] = 8'h6A;
        kb_mem[60] = 8'h75;
        kb_mem[61] = 8'h37;
        kb_mem[62] = 8'h38;
        kb_mem[63] = 8'h00;
        kb_mem[64] = 8'h00;
        kb_mem[65] = 8'h2C;
        kb_mem[66] = 8'h6B;
        kb_mem[67] = 8'h69;
        kb_mem[68] = 8'h6F;
        kb_mem[69] = 8'h30;
        kb_mem[70] = 8'h39;
        kb_mem[71] = 8'h00;
        kb_mem[72] = 8'h00;
        kb_mem[73] = 8'h2E;
        kb_mem[74] = 8'h2F;
        kb_mem[75] = 8'h6C;
        kb_mem[76] = 8'h3A;
        kb_mem[77] = 8'h71;
        kb_mem[78] = 8'h2D;
        kb_mem[79] = 8'h00;
        kb_mem[80] = 8'h00;
        kb_mem[81] = 8'h00;
        kb_mem[82] = 8'h27;
        kb_mem[83] = 8'h00;
        kb_mem[84] = 8'h5B;
        kb_mem[85] = 8'h3D;
        kb_mem[86] = 8'h00;
        kb_mem[87] = 8'h00;
        kb_mem[88] = 8'h00;
        kb_mem[89] = 8'h00;
        kb_mem[90] = 8'h0D;
        kb_mem[91] = 8'h5D;
        kb_mem[92] = 8'h00;
        kb_mem[93] = 8'h5C;
        kb_mem[94] = 8'h00;
        kb_mem[95] = 8'h00;
        kb_mem[96] = 8'h00;
        kb_mem[97] = 8'h00;
        kb_mem[98] = 8'h00;
        kb_mem[99] = 8'h00;
        kb_mem[100] = 8'h00;
        kb_mem[101] = 8'h00;
        kb_mem[102] = 8'h08;
        kb_mem[103] = 8'h00;
        kb_mem[104] = 8'h00;
        kb_mem[105] = 8'h31;
        kb_mem[106] = 8'h00;
        kb_mem[107] = 8'h34;
        kb_mem[108] = 8'h37;
        kb_mem[109] = 8'h00;
        kb_mem[110] = 8'h00;
        kb_mem[111] = 8'h00;
        kb_mem[112] = 8'h30;
        kb_mem[113] = 8'h2E;
        kb_mem[114] = 8'h32;
        kb_mem[115] = 8'h35;
        kb_mem[116] = 8'h36;
        kb_mem[117] = 8'h38;
        kb_mem[118] = 8'h00;
        kb_mem[119] = 8'h00;
        kb_mem[120] = 8'h00;
        kb_mem[121] = 8'h2B;
        kb_mem[122] = 8'h33;
        kb_mem[123] = 8'h2C;
        kb_mem[124] = 8'h2A;
        kb_mem[125] = 8'h39;
        kb_mem[126] = 8'h00;
        kb_mem[127] = 8'h00;
        kb_mem[128] = 8'h00;
        kb_mem[129] = 8'h00;
        kb_mem[130] = 8'h00;
        kb_mem[131] = 8'h00;
        kb_mem[132] = 8'h00;
        kb_mem[133] = 8'h00;
        kb_mem[134] = 8'h00;
        kb_mem[135] = 8'h00;
        kb_mem[136] = 8'h00;
        kb_mem[137] = 8'h00;
        kb_mem[138] = 8'h00;
        kb_mem[139] = 8'h00;
        kb_mem[140] = 8'h00;
        kb_mem[141] = 8'h00;
        kb_mem[142] = 8'h00;
        kb_mem[143] = 8'h00;
        kb_mem[144] = 8'h00;
        kb_mem[145] = 8'h00;
        kb_mem[146] = 8'h00;
        kb_mem[147] = 8'h00;
        kb_mem[148] = 8'h00;
        kb_mem[149] = 8'h00;
        kb_mem[150] = 8'h00;
        kb_mem[151] = 8'h00;
        kb_mem[152] = 8'h00;
        kb_mem[153] = 8'h00;
        kb_mem[154] = 8'h00;
        kb_mem[155] = 8'h00;
        kb_mem[156] = 8'h00;
        kb_mem[157] = 8'h00;
        kb_mem[158] = 8'h00;
        kb_mem[159] = 8'h00;
        kb_mem[160] = 8'h00;
        kb_mem[161] = 8'h00;
        kb_mem[162] = 8'h00;
        kb_mem[163] = 8'h00;
        kb_mem[164] = 8'h00;
        kb_mem[165] = 8'h00;
        kb_mem[166] = 8'h00;
        kb_mem[167] = 8'h00;
        kb_mem[168] = 8'h00;
        kb_mem[169] = 8'h00;
        kb_mem[170] = 8'h00;
        kb_mem[171] = 8'h00;
        kb_mem[172] = 8'h00;
        kb_mem[173] = 8'h00;
        kb_mem[174] = 8'h00;
        kb_mem[175] = 8'h00;
        kb_mem[176] = 8'h00;
        kb_mem[177] = 8'h00;
        kb_mem[178] = 8'h00;
        kb_mem[179] = 8'h00;
        kb_mem[180] = 8'h00;
        kb_mem[181] = 8'h00;
        kb_mem[182] = 8'h00;
        kb_mem[183] = 8'h00;
        kb_mem[184] = 8'h00;
        kb_mem[185] = 8'h00;
        kb_mem[186] = 8'h00;
        kb_mem[187] = 8'h00;
        kb_mem[188] = 8'h00;
        kb_mem[189] = 8'h00;
        kb_mem[190] = 8'h00;
        kb_mem[191] = 8'h00;
        kb_mem[192] = 8'h00;
        kb_mem[193] = 8'h00;
        kb_mem[194] = 8'h00;
        kb_mem[195] = 8'h00;
        kb_mem[196] = 8'h00;
        kb_mem[197] = 8'h00;
        kb_mem[198] = 8'h00;
        kb_mem[199] = 8'h00;
        kb_mem[200] = 8'h00;
        kb_mem[201] = 8'h00;
        kb_mem[202] = 8'h00;
        kb_mem[203] = 8'h00;
        kb_mem[204] = 8'h00;
        kb_mem[205] = 8'h00;
        kb_mem[206] = 8'h00;
        kb_mem[207] = 8'h00;
        kb_mem[208] = 8'h00;
        kb_mem[209] = 8'h00;
        kb_mem[210] = 8'h00;
        kb_mem[211] = 8'h00;
        kb_mem[212] = 8'h00;
        kb_mem[213] = 8'h00;
        kb_mem[214] = 8'h00;
        kb_mem[215] = 8'h00;
        kb_mem[216] = 8'h00;
        kb_mem[217] = 8'h00;
        kb_mem[218] = 8'h00;
        kb_mem[219] = 8'h00;
        kb_mem[220] = 8'h00;
        kb_mem[221] = 8'h00;
        kb_mem[222] = 8'h00;
        kb_mem[223] = 8'h00;
        kb_mem[224] = 8'h00;
        kb_mem[225] = 8'h00;
        kb_mem[226] = 8'h00;
        kb_mem[227] = 8'h00;
        kb_mem[228] = 8'h00;
        kb_mem[229] = 8'h00;
        kb_mem[230] = 8'h00;
        kb_mem[231] = 8'h00;
        kb_mem[232] = 8'h00;
        kb_mem[233] = 8'h00;
        kb_mem[234] = 8'h00;
        kb_mem[235] = 8'h00;
        kb_mem[236] = 8'h00;
        kb_mem[237] = 8'h00;
        kb_mem[238] = 8'h00;
        kb_mem[239] = 8'h00;
        kb_mem[240] = 8'h00;
        kb_mem[241] = 8'h00;
        kb_mem[242] = 8'h00;
        kb_mem[243] = 8'h00;
        kb_mem[244] = 8'h00;
        kb_mem[245] = 8'h00;
        kb_mem[246] = 8'h00;
        kb_mem[247] = 8'h00;
        kb_mem[248] = 8'h00;
        kb_mem[249] = 8'h00;
        kb_mem[250] = 8'h00;
        kb_mem[251] = 8'h00;
        kb_mem[252] = 8'h00;
        kb_mem[253] = 8'h00;
        kb_mem[254] = 8'h00;
        kb_mem[255] = 8'h00;
    end
    assign   asciicode = kb_mem[kbcode];
endmodule
```

## 功能模块

### 整体设计

该试验中总共有4个功能，分别是绘图、显示图像、输入文字和计算器。

### 模块设计

#### 显示图像

直接将图像文件写入block memory IP核心，然后将其输入连接上VGA控制器，输出连接到显示总线：

```verilog
// use reg to simulate

module img(
    input clka,
    input ena,
    input wea,
    input [31:0] addra,
    input [11:0] dina,
    output [11:0] douta
);

    
    /* verilator lint_off WIDTHTRUNC */
    wire [31:0] pix_x = addra % 640, pix_y = addra / 640;
    img_mem0 my_pic(.clka(clka),.ena(1'b1),.wea(1'b0),.addra({addra}),.dina(12'd0),.douta(douta));
endmodule
```

#### 绘图

接收像素地址并使用组合逻辑电路生成函数值并输出到显示总线：
```verilog
module Graphic(
    input clka,
    input ena,
    input wea,
    input [31:0] addra,
    input [11:0] dina,
    output [11:0] douta
);

    reg [11:0] vreg [307199:0];
    initial begin
        
    end
    /* verilator lint_off WIDTHTRUNC */
    wire [31:0] pix_x = addra % 640, pix_y = addra / 640;

    /* verilator lint_on WIDTHTRUNC */
    // here is the temporary test, we ignore those dangerous behaviors
    wire [31:0] pix_data_R, pix_data_G, pix_data_B;
    assign pix_data_R = (pix_x / 80) + (pix_y / 60);//temp_r[7:4];
    assign pix_data_G = (pix_x / 40);//temp_g[7:4];
    assign pix_data_B = (pix_y / 30);//temp_b[7:4];

    //assign output = vreg[addr];
    assign douta = ((480 - pix_y) >((pix_x - 320)*(pix_x - 320)) / 250) ? {pix_data_R[3:0], pix_data_G[3:0], pix_data_B[3:0]} : 0 ;//pix_data;
endmodule
```

#### 文本输入

该模块处理键盘输入并在显示设备上显示文本。以下是其主要功能：

- **初始化文本存储**：在内存中预先存储了一段文本。
- **地址计算**：计算字符在显示设备上的位置。
- **键盘输入处理**：根据键盘信号`kbsig`和有效性信号`in_valid`，更新文本存储和指针`ptr`。
- **字符像素生成**：调用`get_charpix`模块，根据当前字符和指针位置生成像素数据。
- **输出**：生成的像素数据通过`douta`输出。

模块在每个时钟周期检查输入信号，并根据这些信号更新文本数组`text`。例如，如果接收到回车键（ASCII码`0x0D`），指针会移动到下一行的开始位置。其他键盘信号用于移动指针或删除字符。最终，模块输出字符的像素表示，用于在显示设备上渲染文本。这个模块是文本编辑器硬件实现的一部分，负责文本的输入、处理和显示。

```verilog
module txt(
    input [31:0] addra,
    input [7:0] ascii_in,
    input [15:0] kbsig,//8:u, 7:d, 6:l, 5:r
    input clk,
    input in_valid,
    output [11:0] douta,
    input available
);
    wire out;
    reg [7:0] text [2399:0];
    reg [31:0] ptr = 80;
    initial begin
        text[0] = 8'd69;
        text[1] = 8'd118;
        text[2] = 8'd101;
        text[3] = 8'd114;
        text[4] = 8'd121;
        text[5] = 8'd116;
        text[6] = 8'd104;
        text[7] = 8'd105;
        text[8] = 8'd110;
        text[9] = 8'd103;
        text[10] = 8'd32;
        text[11] = 8'd105;
        text[12] = 8'd115;
        text[13] = 8'd32;
        text[14] = 8'd97;
        text[15] = 8'd32;
        text[16] = 8'd115;
        text[17] = 8'd116;
        text[18] = 8'd97;
        text[19] = 8'd116;
        text[20] = 8'd101;
        text[21] = 8'd32;
        text[22] = 8'd109;
        text[23] = 8'd97;
        text[24] = 8'd99;
        text[25] = 8'd104;
        text[26] = 8'd105;
        text[27] = 8'd110;
        text[28] = 8'd101;
        text[29] = 8'd46;
    end
    wire [31:0] xw = addra % 8, yw = ((addra / 640) % 16);
    
    always @(posedge clk) begin
        if(available == 1)begin
            if(in_valid == 1)begin
                $display("ascii : %d", ascii_in);
                if(ascii_in == 8'h0D)begin
                    ptr <= (ptr < 2400 - 80) ? ((ptr + 80) - (ptr % 80)) : ptr;
                end else begin
                    text[ptr] <= ascii_in;
                    if(kbsig[8] == 0 & kbsig[7] == 0 & kbsig[6] == 0 & kbsig[5] == 0 & kbsig[9] == 0)begin
                        ptr <= (ptr < 2399) ? ptr + 1 : ptr;
                    end
                end
            end
            else if(kbsig[8] == 1)begin
                ptr <= (ptr >= 80) ? (ptr - 80) : ptr;
            end
            else if(kbsig[7] == 1)begin
                ptr <= (ptr < 2400 - 80) ? (ptr + 80) : ptr;
            end
            else if(kbsig[6] == 1)begin
                ptr <= (ptr < 2339) ? (ptr + 1) : ptr;
            end
            else if(kbsig[5] == 1)begin
                ptr <= (ptr > 0) ? (ptr - 1) : ptr;
            end
            else if(kbsig[9] == 1) begin
                ptr <= (ptr > 0) ? ptr - 1 : ptr;
                text[(ptr > 0) ? ptr - 1 : ptr] <= 0;
            end
        end
    end

    get_charpix pix(
        .c(text[80 * (addra / (640 * 16)) + (((addra % (640 * 16)) / 8) % 80)]),
        .x(xw[5:0]),
        .y(yw[5:0]),
        .in_ptr((80 * (addra / (640 * 16)) + (((addra % (640 * 16)) / 8) % 80)) == ptr),
        .is_light(out)
    );
    assign douta = (out == 1) ? 12'b111111111111 : 12'd0; 
endmodule
```

`get_charpix`模块主要功能如下：

- **字体存储**：使用一个初始化块，从一个十六进制文件中读取字体数据到`font`数组。
- **像素点生成**：根据输入字符`c`和像素坐标`x`、`y`，确定该像素点是否应该亮起（`is_light`）。

具体来说，`font`数组存储了每个字符的像素映射，`assign`语句计算出在给定的`x`、`y`坐标下，对应字符的像素点是否应该显示。如果`in_ptr`为真且`y`坐标为15（即最底行），则该像素点也会亮起，这可能用于显示光标位置。代码：

```verilog
module get_charpix(
    input [7:0] c,
    input [5:0] x,
    input [5:0] y,
    input in_ptr,
    output is_light
);
    reg [127:0] font [255:0];
    initial begin
      $readmemh("/Users/.../lab6/vsrc/ASC16.hex", font);
    end
    assign is_light = (font[c][127 - ((y * 8) + x)]) | (in_ptr & (y == 15));
    
endmodule
```

#### 计算器

计算器是文本输入模块的一个子类，其会使用文本输入模块来获取输入并在回车按下时对输入进行计算；计算使用符号栈和数字栈来进行表达式求值。

1. **输入输出定义**：
   - `input [31:0] addra`：一个32位宽的输入，可能用于指定字符位置或用于其他计算。
   - `input [7:0] ascii_in`：8位宽的输入，用于接收ASCII码。
   - `input [15:0] kbsig`：16位宽的输入，包含不同的控制信号，例如上（u）、下（d）、左（l）、右（r）等。
   - `input clk`：时钟信号。
   - `input in_valid`：有效输入信号。
   - `output [11:0] douta`：12位宽的输出，可能用于显示或其他目的。
   - `input available`：一个输入信号，可能用于指示模块是否可以处理数据。
2. **内部信号和组件**：
   - `wire out`：一个输出信号，用于指示某些条件是否满足。
   - `reg [7:0] text [239:0]`：一个8位宽、240个元素的寄存器数组，用于存储文本数据。
   - `reg [31:0] ptr`：一个32位宽的寄存器，用作指针或计数器。
   - `wire [31:0] xw, yw`：根据`addra`计算出的x和y坐标。
   - `wire [31:0] chr_location`：根据`addra`计算出字符位置的寄存器。
   - `get_charpix pix`：一个用户定义的组件，可能用于获取字符的像素数据。
3. **状态机**：
   - `reg [31:0] i, j`：用于循环和计数的寄存器。
   - `reg [2:0] state`：表示模块当前状态的寄存器，有多个状态，例如错误状态（7）。
   - `reg [31:0] num_stack[79:0]`：一个栈，用于存储数字。
   - `reg [3:0] sim_stack[79:0]`：一个栈，用于存储操作符。
   - `reg [31:0] sp`：栈指针。
4. **状态机逻辑**：
   - 在时钟上升沿触发的`always`块中，根据`state`和输入信号执行不同的操作。
   - 状态包括处理输入、显示文本、执行计算等。
   - 例如，在状态3'd2中，模块可能正在解析文本中的数字和操作符，并执行计算。
5. **输出逻辑**：
   - `assign douta`：根据`out`信号的状态，将`douta`设置为全1或0。
6. **其他**：
   - 模块中使用了条件语句和循环来处理不同的逻辑分支。
   - 有用于错误处理和状态转换的逻辑。

整体来看，这个模块是一个文本界面的计算器，它可以接收键盘输入，执行基本的数学运算，并显示结果。模块内部使用状态机来管理不同的操作状态，并使用栈来处理数值和运算符。

```verilog
module Calculator(
    input [31:0] addra,
    input [7:0] ascii_in,
    input [15:0] kbsig,//8:u, 7:d, 6:l, 5:r
    input clk,
    input in_valid,
    output [11:0] douta,
    input available
);
    wire out;
    reg [7:0] text [239:0];
    reg [31:0] ptr = 0;
    wire [31:0] xw = addra % 8, yw = ((addra / 640) % 16);
    wire [31:0] chr_location = 80 * (addra / (640 * 16)) + (((addra % (640 * 16)) / 8) % 80);
    get_charpix pix(
        .c((chr_location <= 32'd239) ? text[chr_location] : 8'd0),
        .x(xw[5:0]),
        .y(yw[5:0]),
        .in_ptr((80 * (addra / (640 * 16)) + (((addra % (640 * 16)) / 8) % 80)) == ptr),
        .is_light(out)
    );
    reg [31:0] i, j;
    reg [2:0]state;//error : 7
    reg [31:0]num_stack[79:0];
    reg [31:0]temp;
    reg [3:0]sim_stack[79:0];
    reg [31:0]sp;
    always @(posedge clk) begin
        // $display("state : %d", state);
        if(available == 1)begin
            if(state == 3'd6)begin
                if(i == 0)begin
                    state <= 0;
                    sp <= 0;
                    j <= 0;
                    ptr <= 0;
                    num_stack[0] <= 0;
                    sim_stack[0] <= 0;
                end else begin
                    i <= i - 1;
                end
                text[i] <= 0;
            end else if(state == 3'd7)begin
                state <= 6;
                i <= ptr;
                text[80] <= 8'd115;
                text[81] <= 8'd121;
                text[82] <= 8'd110;
                text[83] <= 8'd116;
                text[84] <= 8'd97;
                text[85] <= 8'd120;
                text[86] <= 8'd32;
                text[87] <= 8'd101;
                text[88] <= 8'd114;
                text[89] <= 8'd114;
                text[90] <= 8'd111;
                text[91] <= 8'd114;
                text[92] <= 8'd32;
                text[93] <= 8'd33;
                text[94] <= 8'd33;
                text[95] <= 8'd33;
                text[96] <= 8'd33;
                text[97] <= 8'd33;
            end else if(state == 3'd4)begin
                if(j == 0)begin
                    i <= 0;
                    state <= 0;
                    sp <= 0;
                    ptr <= 0;
                    num_stack[0] <= 0;
                    sim_stack[0] <= 0;
                end else if(i == 0)begin
                    j <= j - 1;
                    text[j] <= text[i];
                end else begin
                    i <= i - 1;
                    j <= j - 1;
                    if(i == ptr)begin
                        text[j] <= 8'd61;
                    end else begin
                        text[j] <= text[i];
                    end
                end
                text[i] <= 0;
            end
            if(state == 3'd3)begin
                //$display("state 3 j : %d", j);
                if(num_stack[0] / 10 == 0)begin
                    state <= 3'd4;
                    num_stack[0] <= 0;
                    sim_stack[0] <= 0;
                end
                /* verilator lint_off WIDTHTRUNC */
                text[j] <= (num_stack[0] % 10) + 32'd48;
                num_stack[0] <= num_stack[0] / 10;
                j <= j - 1;
                /* verilator lint_on WIDTHTRUNC */
            end
            if(state == 3'd2)begin
                $display("state 2 i = %d\nptr = %d\n temp = %d", i, ptr, temp);
                if(i == ptr)begin
                    state <= 3'd3;
                    j <= 32'd159;
                end else begin
                    i <= i + 1;
                end
                if(text[i] <= 8'd57 && text[i] >= 8'd48)begin
                    case (text[i])
                        8'd48:   temp <= (temp * 10) + 32'd0;
                        8'd49:   temp <= (temp * 10) + 32'd1;
                        8'd50:   temp <= (temp * 10) + 32'd2;
                        8'd51:   temp <= (temp * 10) + 32'd3;
                        8'd52:   temp <= (temp * 10) + 32'd4;
                        8'd53:   temp <= (temp * 10) + 32'd5;
                        8'd54:   temp <= (temp * 10) + 32'd6;
                        8'd55:   temp <= (temp * 10) + 32'd7;
                        8'd56:   temp <= (temp * 10) + 32'd8;
                        8'd57:   temp <= (temp * 10) + 32'd9;
                        default : ;
                    endcase
                end else if(text[i] != 8'd40 && text[i] != 8'd41)begin
                    if(sim_stack[sp] != 4'd0)begin
                        case (sim_stack[sp])
                            4'd1:begin
                                num_stack[sp] <= num_stack[sp] + temp;
                            end 
                            4'd2:begin
                                num_stack[sp] <= num_stack[sp] - temp;
                            end 
                            4'd3:begin
                                num_stack[sp] <= num_stack[sp] * temp;
                            end 
                            4'd4:begin
                                num_stack[sp] <= num_stack[sp] / temp;
                            end 
                            default : ;
                        endcase
                    end else begin
                        num_stack[sp] <= temp;
                    end
                    temp <= 0;
                    case (text[i])
                        8'd43:begin
                            sim_stack[sp] <= 4'd1;
                        end 
                        8'd45:begin
                            sim_stack[sp] <= 4'd2;
                        end 
                        8'd42:begin
                            sim_stack[sp] <= 4'd3;
                        end 
                        8'd47:begin
                            sim_stack[sp] <= 4'd4;
                        end 
                        default:begin
                            if(i != ptr)begin
                                state <= 3'd7;
                            end
                        end
                    endcase
                end else if(text[i] == 8'd40)begin
                    num_stack[sp + 1] <= 0;
                    sim_stack[sp + 1] <= 0;
                    sp <= sp + 1;
                end else if(text[i] == 8'd41)begin
                    if(sp == 0)begin
                        state <= 3'd7;
                    end else begin
                        case (sim_stack[sp])
                            4'd1:begin
                                temp <= num_stack[sp] + temp;
                            end 
                            4'd2:begin
                                temp <= num_stack[sp] - temp;
                            end 
                            4'd3:begin
                                temp <= num_stack[sp] * temp;
                            end 
                            4'd4:begin
                                temp <= num_stack[sp] / temp;
                            end 
                            default : ;
                        endcase
                        sp <= sp - 1;
                        num_stack[sp] <= 0;
                        sim_stack[sp] <= 0;
                    end
                end 
            end else if(state == 3'd1)begin
                if(ptr == 32'd2400)begin
                    sp <= 0;
                    i <= 0;
                    ptr <= 0;
                    state <= 0;
                    num_stack[0] <= 0;
                    sim_stack[0] <= 0;
                end else begin
                    text[ptr] <= 0;
                    ptr <= ptr + 1;
                end
            end else if(state == 3'd0)begin
                if(in_valid == 1)begin
                    $display("ascii : %d", ascii_in);
                    if(ascii_in == 8'h0D)begin
                        i <= 0;
                        num_stack[0] <= 0;
                        sim_stack[0] <= 0;
                        sp <= 0;
                        state <= 3'd2;
                    end else begin
                        if(kbsig[3] == 1 && ascii_in == 100)begin
                            ptr <= 0;
                            state <= 3'd1;
                        end else begin
                            if(ascii_in != 8'd32)begin
                                text[ptr] <= ascii_in;
                                if(kbsig[8] == 0 & kbsig[7] == 0 & kbsig[6] == 0 & kbsig[5] == 0 & kbsig[9] == 0)begin
                                    ptr <= (ptr < 2399) ? ptr + 1 : ptr;
                                end
                            end
                        end
                    end
                end
                else if(kbsig[9] == 1) begin
                    ptr <= (ptr > 0) ? ptr - 1 : ptr;
                    text[(ptr > 0) ? ptr - 1 : ptr] <= 0;
                end
            end
        end
    end

    assign douta = (out == 1) ? 12'b111111111111 : 12'd0; 
endmodule
```

#### 控制台

控制台负责显示提示信息并从键盘获取输入，给控制器输出控制信号。

```verilog

module term_man(
    input [31:0] addra,
    input [7:0] ascii_in,
    input [15:0] kbsig,//8:u, 7:d, 6:l, 5:r
    input clk,
    input in_valid,
    output [11:0] douta,
    output [2:0] state
);
    wire out;
    reg [7:0] text [1199:0];
    wire [31:0] chr_location = 80 * (addra / (640 * 16)) + (((addra % (640 * 16)) / 8) % 80);
    reg [31:0] ptr = 402;
    reg [2:0] state_R = 0;
    assign state = state_R;
    initial begin
        text[0] = 8'd45;
        text[1] = 8'd45;
        text[2] = 8'd45;
        text[3] = 8'd45;
        text[4] = 8'd45;
        text[5] = 8'd45;
        text[6] = 8'd45;
        text[7] = 8'd88;
        text[8] = 8'd116;
        text[9] = 8'd101;
        text[10] = 8'd114;
        text[11] = 8'd109;
        text[12] = 8'd105;
        text[13] = 8'd110;
        text[14] = 8'd97;
        text[15] = 8'd108;
        text[16] = 8'd45;
        text[17] = 8'd45;
        text[18] = 8'd45;
        text[19] = 8'd45;
        text[20] = 8'd45;
        text[21] = 8'd45;
        text[22] = 8'd45;
        text[23] = 8'd45;
        text[24] = 8'd45;
        text[25] = 8'd45;
        text[26] = 8'd45;
        text[27] = 8'd45;
        text[28] = 8'd45;
        text[29] = 8'd45;
        text[30] = 8'd45;
        text[31] = 8'd45;
        text[32] = 8'd45;
        text[33] = 8'd45;
        text[34] = 8'd45;
        text[35] = 8'd45;
        text[36] = 8'd45;
        text[37] = 8'd45;
        text[38] = 8'd45;
        text[39] = 8'd45;
        text[40] = 8'd45;
        text[41] = 8'd45;
        text[42] = 8'd91;
        text[43] = 8'd50;
        text[44] = 8'd49;
        text[45] = 8'd49;
        text[46] = 8'd53;
        text[47] = 8'd48;
        text[48] = 8'd50;
        text[49] = 8'd48;
        text[50] = 8'd48;
        text[51] = 8'd56;
        text[52] = 8'd93;
        text[53] = 8'd45;
        text[54] = 8'd45;
        text[55] = 8'd91;
        text[56] = 8'd67;
        text[57] = 8'd104;
        text[58] = 8'd101;
        text[59] = 8'd110;
        text[60] = 8'd103;
        text[61] = 8'd120;
        text[62] = 8'd105;
        text[63] = 8'd95;
        text[64] = 8'd76;
        text[65] = 8'd105;
        text[66] = 8'd93;
        text[67] = 8'd45;
        text[68] = 8'd45;
        text[69] = 8'd91;
        text[70] = 8'd50;
        text[71] = 8'd51;
        text[72] = 8'd58;
        text[73] = 8'd52;
        text[74] = 8'd58;
        text[75] = 8'd50;
        text[76] = 8'd51;
        text[77] = 8'd93;
        text[78] = 8'd45;
        text[79] = 8'd45;
        text[80] = 8'd91;
        text[81] = 8'd71;
        text[82] = 8'd93;
        text[83] = 8'd114;
        text[84] = 8'd97;
        text[85] = 8'd112;
        text[86] = 8'd104;
        text[87] = 8'd105;
        text[88] = 8'd99;
        text[89] = 8'd115;
        text[90] = 8'd32;
        text[91] = 8'd32;
        text[92] = 8'd32;
        text[93] = 8'd32;
        text[94] = 8'd32;
        text[95] = 8'd32;
        text[96] = 8'd32;
        text[97] = 8'd32;
        text[98] = 8'd32;
        text[99] = 8'd32;
        text[100] = 8'd32;
        text[101] = 8'd32;
        text[102] = 8'd32;
        text[103] = 8'd32;
        text[104] = 8'd32;
        text[105] = 8'd32;
        text[106] = 8'd32;
        text[107] = 8'd32;
        text[108] = 8'd32;
        text[109] = 8'd32;
        text[110] = 8'd32;
        text[111] = 8'd32;
        text[112] = 8'd32;
        text[113] = 8'd32;
        text[114] = 8'd32;
        text[115] = 8'd32;
        text[116] = 8'd32;
        text[117] = 8'd32;
        text[118] = 8'd32;
        text[119] = 8'd32;
        text[120] = 8'd32;
        text[121] = 8'd32;
        text[122] = 8'd32;
        text[123] = 8'd32;
        text[124] = 8'd32;
        text[125] = 8'd32;
        text[126] = 8'd32;
        text[127] = 8'd32;
        text[128] = 8'd32;
        text[129] = 8'd32;
        text[130] = 8'd32;
        text[131] = 8'd32;
        text[132] = 8'd32;
        text[133] = 8'd32;
        text[134] = 8'd32;
        text[135] = 8'd32;
        text[136] = 8'd32;
        text[137] = 8'd32;
        text[138] = 8'd32;
        text[139] = 8'd32;
        text[140] = 8'd32;
        text[141] = 8'd32;
        text[142] = 8'd32;
        text[143] = 8'd32;
        text[144] = 8'd32;
        text[145] = 8'd32;
        text[146] = 8'd32;
        text[147] = 8'd32;
        text[148] = 8'd32;
        text[149] = 8'd32;
        text[150] = 8'd32;
        text[151] = 8'd32;
        text[152] = 8'd32;
        text[153] = 8'd32;
        text[154] = 8'd32;
        text[155] = 8'd32;
        text[156] = 8'd32;
        text[157] = 8'd32;
        text[158] = 8'd32;
        text[159] = 8'd32;
        text[160] = 8'd91;
        text[161] = 8'd73;
        text[162] = 8'd93;
        text[163] = 8'd109;
        text[164] = 8'd97;
        text[165] = 8'd103;
        text[166] = 8'd101;
        text[167] = 8'd32;
        text[168] = 8'd32;
        text[169] = 8'd32;
        text[170] = 8'd32;
        text[171] = 8'd32;
        text[172] = 8'd32;
        text[173] = 8'd32;
        text[174] = 8'd32;
        text[175] = 8'd32;
        text[176] = 8'd32;
        text[177] = 8'd32;
        text[178] = 8'd32;
        text[179] = 8'd32;
        text[180] = 8'd32;
        text[181] = 8'd32;
        text[182] = 8'd32;
        text[183] = 8'd32;
        text[184] = 8'd32;
        text[185] = 8'd32;
        text[186] = 8'd32;
        text[187] = 8'd32;
        text[188] = 8'd32;
        text[189] = 8'd32;
        text[190] = 8'd32;
        text[191] = 8'd32;
        text[192] = 8'd32;
        text[193] = 8'd32;
        text[194] = 8'd32;
        text[195] = 8'd32;
        text[196] = 8'd32;
        text[197] = 8'd32;
        text[198] = 8'd32;
        text[199] = 8'd32;
        text[200] = 8'd32;
        text[201] = 8'd32;
        text[202] = 8'd32;
        text[203] = 8'd32;
        text[204] = 8'd32;
        text[205] = 8'd32;
        text[206] = 8'd32;
        text[207] = 8'd32;
        text[208] = 8'd32;
        text[209] = 8'd32;
        text[210] = 8'd32;
        text[211] = 8'd32;
        text[212] = 8'd32;
        text[213] = 8'd32;
        text[214] = 8'd32;
        text[215] = 8'd32;
        text[216] = 8'd32;
        text[217] = 8'd32;
        text[218] = 8'd32;
        text[219] = 8'd32;
        text[220] = 8'd32;
        text[221] = 8'd32;
        text[222] = 8'd32;
        text[223] = 8'd32;
        text[224] = 8'd32;
        text[225] = 8'd32;
        text[226] = 8'd32;
        text[227] = 8'd32;
        text[228] = 8'd32;
        text[229] = 8'd32;
        text[230] = 8'd32;
        text[231] = 8'd32;
        text[232] = 8'd32;
        text[233] = 8'd32;
        text[234] = 8'd32;
        text[235] = 8'd32;
        text[236] = 8'd32;
        text[237] = 8'd32;
        text[238] = 8'd32;
        text[239] = 8'd32;
        text[240] = 8'd91;
        text[241] = 8'd84;
        text[242] = 8'd93;
        text[243] = 8'd120;
        text[244] = 8'd116;
        text[245] = 8'd32;
        text[246] = 8'd32;
        text[247] = 8'd32;
        text[248] = 8'd32;
        text[249] = 8'd32;
        text[250] = 8'd32;
        text[251] = 8'd32;
        text[252] = 8'd32;
        text[253] = 8'd32;
        text[254] = 8'd32;
        text[255] = 8'd32;
        text[256] = 8'd32;
        text[257] = 8'd32;
        text[258] = 8'd32;
        text[259] = 8'd32;
        text[260] = 8'd32;
        text[261] = 8'd32;
        text[262] = 8'd32;
        text[263] = 8'd32;
        text[264] = 8'd32;
        text[265] = 8'd32;
        text[266] = 8'd32;
        text[267] = 8'd32;
        text[268] = 8'd32;
        text[269] = 8'd32;
        text[270] = 8'd32;
        text[271] = 8'd32;
        text[272] = 8'd32;
        text[273] = 8'd32;
        text[274] = 8'd32;
        text[275] = 8'd32;
        text[276] = 8'd32;
        text[277] = 8'd32;
        text[278] = 8'd32;
        text[279] = 8'd32;
        text[280] = 8'd32;
        text[281] = 8'd32;
        text[282] = 8'd32;
        text[283] = 8'd32;
        text[284] = 8'd32;
        text[285] = 8'd32;
        text[286] = 8'd32;
        text[287] = 8'd32;
        text[288] = 8'd32;
        text[289] = 8'd32;
        text[290] = 8'd32;
        text[291] = 8'd32;
        text[292] = 8'd32;
        text[293] = 8'd32;
        text[294] = 8'd32;
        text[295] = 8'd32;
        text[296] = 8'd32;
        text[297] = 8'd32;
        text[298] = 8'd32;
        text[299] = 8'd32;
        text[300] = 8'd32;
        text[301] = 8'd32;
        text[302] = 8'd32;
        text[303] = 8'd32;
        text[304] = 8'd32;
        text[305] = 8'd32;
        text[306] = 8'd32;
        text[307] = 8'd32;
        text[308] = 8'd32;
        text[309] = 8'd32;
        text[310] = 8'd32;
        text[311] = 8'd32;
        text[312] = 8'd32;
        text[313] = 8'd32;
        text[314] = 8'd32;
        text[315] = 8'd32;
        text[316] = 8'd32;
        text[317] = 8'd32;
        text[318] = 8'd32;
        text[319] = 8'd32;
        text[320] = 8'd91;
        text[321] = 8'd67;
        text[322] = 8'd93;
        text[323] = 8'd97;
        text[324] = 8'd108;
        text[325] = 8'd99;
        text[326] = 8'd117;
        text[327] = 8'd108;
        text[328] = 8'd97;
        text[329] = 8'd116;
        text[330] = 8'd111;
        text[331] = 8'd114;
        text[332] = 8'd32;
        text[333] = 8'd32;
        text[334] = 8'd32;
        text[335] = 8'd32;
        text[336] = 8'd32;
        text[337] = 8'd32;
        text[338] = 8'd32;
        text[339] = 8'd32;
        text[340] = 8'd32;
        text[341] = 8'd32;
        text[342] = 8'd32;
        text[343] = 8'd32;
        text[344] = 8'd32;
        text[345] = 8'd32;
        text[346] = 8'd32;
        text[347] = 8'd32;
        text[348] = 8'd32;
        text[349] = 8'd32;
        text[350] = 8'd32;
        text[351] = 8'd32;
        text[352] = 8'd32;
        text[353] = 8'd32;
        text[354] = 8'd32;
        text[355] = 8'd32;
        text[356] = 8'd32;
        text[357] = 8'd32;
        text[358] = 8'd32;
        text[359] = 8'd32;
        text[360] = 8'd32;
        text[361] = 8'd32;
        text[362] = 8'd32;
        text[363] = 8'd32;
        text[364] = 8'd32;
        text[365] = 8'd32;
        text[366] = 8'd32;
        text[367] = 8'd32;
        text[368] = 8'd32;
        text[369] = 8'd32;
        text[370] = 8'd32;
        text[371] = 8'd32;
        text[372] = 8'd32;
        text[373] = 8'd32;
        text[374] = 8'd32;
        text[375] = 8'd32;
        text[376] = 8'd32;
        text[377] = 8'd32;
        text[378] = 8'd32;
        text[379] = 8'd32;
        text[380] = 8'd32;
        text[381] = 8'd32;
        text[382] = 8'd32;
        text[383] = 8'd32;
        text[384] = 8'd32;
        text[385] = 8'd32;
        text[386] = 8'd32;
        text[387] = 8'd32;
        text[388] = 8'd32;
        text[389] = 8'd32;
        text[390] = 8'd32;
        text[391] = 8'd32;
        text[392] = 8'd32;
        text[393] = 8'd32;
        text[394] = 8'd32;
        text[395] = 8'd32;
        text[396] = 8'd32;
        text[397] = 8'd32;
        text[398] = 8'd32;
        text[399] = 8'd32;
        text[400] = 8'd45;
        text[401] = 8'd62;
        text[402] = 8'd32;
        text[403] = 8'd32;
        text[404] = 8'd32;
        text[405] = 8'd32;
        text[406] = 8'd32;
        text[407] = 8'd32;
        text[408] = 8'd32;
        text[409] = 8'd32;
        text[410] = 8'd32;
        text[411] = 8'd32;
        text[412] = 8'd32;
        text[413] = 8'd32;
        text[414] = 8'd32;
        text[415] = 8'd32;
        text[416] = 8'd32;
        text[417] = 8'd32;
        text[418] = 8'd32;
        text[419] = 8'd32;
        text[420] = 8'd32;
        text[421] = 8'd32;
        text[422] = 8'd32;
        text[423] = 8'd32;
        text[424] = 8'd32;
        text[425] = 8'd32;
        text[426] = 8'd32;
        text[427] = 8'd32;
        text[428] = 8'd32;
        text[429] = 8'd32;
        text[430] = 8'd32;
        text[431] = 8'd32;
        text[432] = 8'd32;
        text[433] = 8'd32;
        text[434] = 8'd32;
        text[435] = 8'd32;
        text[436] = 8'd32;
        text[437] = 8'd32;
        text[438] = 8'd32;
        text[439] = 8'd32;
        text[440] = 8'd32;
        text[441] = 8'd32;
        text[442] = 8'd32;
        text[443] = 8'd32;
        text[444] = 8'd32;
        text[445] = 8'd32;
        text[446] = 8'd32;
        text[447] = 8'd32;
        text[448] = 8'd32;
        text[449] = 8'd32;
        text[450] = 8'd32;
        text[451] = 8'd32;
        text[452] = 8'd32;
        text[453] = 8'd32;
        text[454] = 8'd32;
        text[455] = 8'd32;
        text[456] = 8'd32;
        text[457] = 8'd32;
        text[458] = 8'd32;
        text[459] = 8'd32;
        text[460] = 8'd32;
        text[461] = 8'd32;
        text[462] = 8'd32;
        text[463] = 8'd32;
        text[464] = 8'd32;
        text[465] = 8'd32;
        text[466] = 8'd32;
        text[467] = 8'd32;
        text[468] = 8'd32;
        text[469] = 8'd32;
        text[470] = 8'd32;
        text[471] = 8'd32;
        text[472] = 8'd32;
        text[473] = 8'd32;
        text[474] = 8'd32;
        text[475] = 8'd32;
        text[476] = 8'd32;
        text[477] = 8'd32;
        text[478] = 8'd32;
        text[479] = 8'd32;
    end
    wire [31:0] xw = addra % 8, yw = ((addra / 640) % 16);

    always @(posedge clk) begin
        if(kbsig[10] == 1) begin
            $display("ESC");
            state_R <= 0;
        end else if(state_R == 0) begin
            if(in_valid == 1) begin
                if(ascii_in == 8'h0D) begin
                    if(text[402] == 8'd84) begin
                        text[402] <= 0;
                        state_R <= 3;
                        ptr <= 32'd402;
                        $display("401 : %d", text[402]);
                        $display("state: %d", state_R);
                        text[480] = 8'd0;
                        text[481] = 8'd0;
                        text[482] = 8'd0;
                        text[483] = 8'd0;
                        text[484] = 8'd0;
                        text[485] = 8'd0;
                        text[486] = 8'd0;
                        text[487] = 8'd0;
                        text[488] = 8'd0;
                        text[489] = 8'd0;
                        text[490] = 8'd0;
                        text[491] = 8'd0;
                        text[492] = 8'd0;
                        text[493] = 8'd0;
                        text[494] = 8'd0;
                        text[495] = 8'd0;
                        text[496] = 8'd0;
                        text[497] = 8'd0;
                    end else if(text[402] == 8'd71) begin
                        text[402] <= 0;
                        state_R <= 1;
                        ptr <= 32'd402;
                        $display("401 : %d", text[402]);
                        $display("state: %d", state_R);
                        text[480] = 8'd0;
                        text[481] = 8'd0;
                        text[482] = 8'd0;
                        text[483] = 8'd0;
                        text[484] = 8'd0;
                        text[485] = 8'd0;
                        text[486] = 8'd0;
                        text[487] = 8'd0;
                        text[488] = 8'd0;
                        text[489] = 8'd0;
                        text[490] = 8'd0;
                        text[491] = 8'd0;
                        text[492] = 8'd0;
                        text[493] = 8'd0;
                        text[494] = 8'd0;
                        text[495] = 8'd0;
                        text[496] = 8'd0;
                        text[497] = 8'd0;
                    end else if(text[402] == 8'd67) begin
                        text[402] <= 0;
                        state_R <= 4;
                        ptr <= 32'd402;
                        $display("401 : %d", text[402]);
                        $display("state: %d", state_R);
                        text[480] = 8'd0;
                        text[481] = 8'd0;
                        text[482] = 8'd0;
                        text[483] = 8'd0;
                        text[484] = 8'd0;
                        text[485] = 8'd0;
                        text[486] = 8'd0;
                        text[487] = 8'd0;
                        text[488] = 8'd0;
                        text[489] = 8'd0;
                        text[490] = 8'd0;
                        text[491] = 8'd0;
                        text[492] = 8'd0;
                        text[493] = 8'd0;
                        text[494] = 8'd0;
                        text[495] = 8'd0;
                        text[496] = 8'd0;
                        text[497] = 8'd0;
                    end else begin// display "Syntax error !!!!!" and clear word typed
                        ptr <= 402;
                        text[480] = 8'd83;
                        text[481] = 8'd121;
                        text[482] = 8'd110;
                        text[483] = 8'd116;
                        text[484] = 8'd97;
                        text[485] = 8'd120;
                        text[486] = 8'd32;
                        text[487] = 8'd101;
                        text[488] = 8'd114;
                        text[489] = 8'd114;
                        text[490] = 8'd111;
                        text[491] = 8'd114;
                        text[492] = 8'd32;
                        text[493] = 8'd33;
                        text[494] = 8'd33;
                        text[495] = 8'd33;
                        text[496] = 8'd33;
                        text[497] = 8'd33;
                        text[401] = 8'd62;
                        text[402] = 8'd0;
                        text[403] = 8'd0;
                        text[404] = 8'd0;
                        text[405] = 8'd0;
                        text[406] = 8'd0;
                        text[407] = 8'd0;
                        text[408] = 8'd0;
                        text[409] = 8'd0;
                        text[410] = 8'd0;
                        text[411] = 8'd0;
                        text[412] = 8'd0;
                        text[413] = 8'd0;
                        text[414] = 8'd0;
                        text[415] = 8'd0;
                        text[416] = 8'd0;
                        text[417] = 8'd0;
                        text[418] = 8'd0;
                        text[419] = 8'd0;
                        text[420] = 8'd0;
                        text[421] = 8'd0;
                        text[422] = 8'd0;
                        text[423] = 8'd0;
                        text[424] = 8'd0;
                        text[425] = 8'd0;
                        text[426] = 8'd0;
                        text[427] = 8'd0;
                        text[428] = 8'd0;
                        text[429] = 8'd0;
                        text[430] = 8'd0;
                        text[431] = 8'd0;
                        text[432] = 8'd0;
                        text[433] = 8'd0;
                        text[434] = 8'd0;
                        text[435] = 8'd0;
                        text[436] = 8'd0;
                        text[437] = 8'd0;
                        text[438] = 8'd0;
                        text[439] = 8'd0;
                        text[440] = 8'd0;
                        text[441] = 8'd0;
                        text[442] = 8'd0;
                        text[443] = 8'd0;
                        text[444] = 8'd0;
                        text[445] = 8'd0;
                        text[446] = 8'd0;
                        text[447] = 8'd0;
                        text[448] = 8'd0;
                        text[449] = 8'd0;
                        text[450] = 8'd0;
                        text[451] = 8'd0;
                        text[452] = 8'd0;
                        text[453] = 8'd0;
                        text[454] = 8'd0;
                        text[455] = 8'd0;
                        text[456] = 8'd0;
                        text[457] = 8'd0;
                        text[458] = 8'd0;
                        text[459] = 8'd0;
                        text[460] = 8'd0;
                        text[461] = 8'd0;
                        text[462] = 8'd0;
                        text[463] = 8'd0;
                        text[464] = 8'd0;
                        text[465] = 8'd0;
                        text[466] = 8'd0;
                        text[467] = 8'd0;
                        text[468] = 8'd0;
                        text[469] = 8'd0;
                        text[470] = 8'd0;
                        text[471] = 8'd0;
                        text[472] = 8'd0;
                        text[473] = 8'd0;
                        text[474] = 8'd0;
                        text[475] = 8'd0;
                        text[476] = 8'd0;
                        text[477] = 8'd0;
                        text[478] = 8'd0;
                        text[479] = 8'd0;
                    end
                end else begin
                    text[ptr] <= ascii_in;
                    if(kbsig[8] == 0 & kbsig[7] == 0 & kbsig[6] == 0 & kbsig[5] == 0 & kbsig[9] == 0)begin
                        ptr <= (ptr < 479) ? ptr + 1 : ptr;
                    end
                end
            end
            else if(kbsig[6] == 1)begin
                ptr <= ((ptr % 80) < 79) ? (ptr + 1) : ptr;
            end
            else if(kbsig[5] == 1)begin
                ptr <= ((ptr % 80) > 2) ? (ptr - 1) : ptr;
            end
            else if(kbsig[9] == 1) begin
                ptr <= (ptr > 401) ? ptr - 1 : ptr;
                if(ptr > 401)begin
                    text[(ptr > 0) ? ptr - 1 : ptr] <= 0;
                end
            end
        end
    end

    get_charpix pix(
        .c((chr_location <= 1199) ? text[chr_location] : 8'd0),
        .x(xw[5:0]),
        .y(yw[5:0]),
        .in_ptr((80 * (addra / (640 * 16)) + (((addra % (640 * 16)) / 8) % 80)) == ptr),
        .is_light(out)
    );

    assign douta = (out == 1) ? 12'b111111111111 : 12'd0; 
endmodule
```



#### 控制器

控制器负责根据控制台输出信号切换显示总线到对应模块并给对应模块输入enable信号。

具体来说，它整合了多个子模块来实现一个基于VGA的文本终端模拟器。以下是其主要组件和功能：

- **时钟信号**：使用100MHz的系统时钟信号。
- **键盘接口**：通过PS2_CLK和PS2_DATA与PS2键盘通信。
- **VGA接口**：通过VGA_R、VGA_G、VGA_B、VGA_HS和VGA_VS信号输出到VGA显示器。
- **状态和地址**：内部状态`state`和视频RAM地址`vram_addr`用于控制显示内容和逻辑流程。
- **显示模拟**：`VGASim`子模块负责生成VGA信号，将文本和图形内容显示在屏幕上。
- **键盘模拟**：`KeyboardSim`子模块处理来自键盘的输入，并将其转换为ASCII码和键盘信号。
- **文本管理**：`term_man`子模块管理文本显示，包括字符的地址映射和状态管理。
- **图形显示**：`Graphic`子模块提供图形显示功能。
- **文本编辑器**：`txt`子模块实现一个简单的文本编辑器，允许用户输入和编辑文本。
- **计算器**：`Calculator`子模块实现一个简单的计算器功能。

整体而言，`xterm`模块是一个多功能的文本和图形显示系统，它可以接收键盘输入，处理文本和计算，以及在VGA显示器上渲染输出。这个模块可能用于教学或嵌入式系统开发中，用于模拟终端操作和显示。

```verilog 

module xterm(
    input CLK100MHZ,   //ϵͳʱ���ź�
    input PS2_CLK,    //���Լ��̵�ʱ���ź�
    input PS2_DATA,  //���Լ��̵Ĵ�������λ
    input BTNC,      //Reset
    output [6:0]SEG,
    output [7:0]AN,     //��ʾɨ�����ASCII��
    output [15:0] LED,   //��ʾ����״̬
    output [3:0] VGA_R,
    output [3:0] VGA_G,
    output [3:0] VGA_B,
    output  VGA_HS,
    output  VGA_VS,
    // for nvboard
    output VALID
);
// Add your code here

    wire [2:0] state;
    wire [31:0] vram_addr;
    wire [11:0] vram_output [4:0];
    wire pix_clk = CLK100MHZ;
    VGASim display(
        .ram_addr(vram_addr),
        .CLK(pix_clk),
        .BTNC(BTNC),
        .VGA_R(VGA_R),
        .VGA_G(VGA_G),
        .VGA_B(VGA_B),
        .VGA_HS(VGA_HS),
        .VGA_VS(VGA_VS),
        .VALID(VALID),
        .vramd_read(vram_output[state])
    );
    wire [7:0] ascii_input;
    wire [10:0] kbsig_input;
    // verilator lint_on INITIALDLY
    //assign LED[4:0] = kbsig_input;
    //assign LED[12:5] = ascii_input;
    //assign LED[13] = PS2_CLK;
    wire kbinput_available;
    KeyboardSim keyboard_0(
        .CLK100MHZ(CLK100MHZ),   //系统时钟信号
        .PS2_CLK(PS2_CLK),    //来自键盘的时钟信号
        .PS2_DATA(PS2_DATA),  //来自键盘的串行数据位
        .BTNC(BTNC),      //Reset
        .ascii_out(ascii_input),
        .kb_sig(kbsig_input),
        .ascii_available(kbinput_available)
    );
    
    term_man term(
        .addra({vram_addr}),
        .ascii_in(ascii_input),
        .kbsig({5'b00000, kbsig_input}),
        .clk(CLK100MHZ),
        .in_valid(kbinput_available),
        .douta(vram_output[0]),
        .state(state)
    );
    Graphic G(.clka(pix_clk),
                    .ena(1'b1),
                    .wea(1'b0),
                    .addra({vram_addr}),
                    .dina(12'd0),
                    .douta(vram_output[1])
    );
    txt my_txt(
        .addra({vram_addr}),
        .ascii_in(ascii_input),
        .kbsig({5'b00000, kbsig_input}),
        .clk(CLK100MHZ),
        .in_valid(kbinput_available),
        .douta(vram_output[3]),
        .available(state == 3'd3)
    );
    Calculator my_Cal(
        .addra({vram_addr}),
        .ascii_in(ascii_input),
        .kbsig({5'b00000, kbsig_input}),
        .clk(CLK100MHZ),
        .in_valid(kbinput_available),
        .douta(vram_output[4]),
        .available(state == 3'd4)
    );
endmodule
```

## 仿真

由于该试验高度抽象，难以从波形图判断工作状态，我使用verilator+NVboard进行仿真。verilator可以将verilog电路转换成一个c++对象进行逻辑仿真，NVboard可以链接verilator对象从而模拟一个FPGA的IO与verilog电路进行直观交互。

使用verilaotr编译verilog项目，并配置NVboard约束。运行生成的可执行文件：

![截屏2024-06-11 16.40.58](/Users/cx_li/Library/Application Support/typora-user-images/截屏2024-06-11 16.40.58.png)

![截屏2024-06-11 16.41.10](/Users/cx_li/Library/Application Support/typora-user-images/截屏2024-06-11 16.42.05.png)

![截屏2024-06-11 16.41.19](/Users/cx_li/Library/Application Support/typora-user-images/截屏2024-06-11 16.41.19.png)

![截屏2024-06-11 16.41.49](/Users/cx_li/Library/Application Support/typora-user-images/截屏2024-06-11 16.41.49.png)

仿真结果可知电路可以按照预期运行。

## 验证

将其综合并生成bitstream：

![lab6](/Users/cx_li/Downloads/lab6.PNG)

由于设计中存在大量需要异步读取的部分，逻辑片占用较大。

烧录入FPGA：

![IMG_2711](/Users/cx_li/Documents/Github/digitalLogic_Lab/digital_logic_exp/lab6/report/IMG_2711.jpeg)

![IMG_2712](/Users/cx_li/Documents/Github/digitalLogic_Lab/digital_logic_exp/lab6/report/IMG_2712.jpeg)

![IMG_2713](/Users/cx_li/Documents/Github/digitalLogic_Lab/digital_logic_exp/lab6/report/IMG_2713.jpeg)

![IMG_2714](/Users/cx_li/Documents/Github/digitalLogic_Lab/digital_logic_exp/lab6/report/IMG_2714.jpeg)

![IMG_2715](/Users/cx_li/Documents/Github/digitalLogic_Lab/digital_logic_exp/lab6/report/IMG_2715.jpeg)

![IMG_2716](/Users/cx_li/Documents/Github/digitalLogic_Lab/digital_logic_exp/lab6/report/IMG_2716.jpeg)

![IMG_2718](/Users/cx_li/Documents/Github/digitalLogic_Lab/digital_logic_exp/lab6/report/IMG_2718.jpeg)

![IMG_2720](/Users/cx_li/Documents/Github/digitalLogic_Lab/digital_logic_exp/lab6/report/IMG_2720.jpeg)

![IMG_2721](/Users/cx_li/Documents/Github/digitalLogic_Lab/digital_logic_exp/lab6/report/IMG_2721.jpeg)

![IMG_2722](/Users/cx_li/Documents/Github/digitalLogic_Lab/digital_logic_exp/lab6/report/IMG_2722.jpeg)

![IMG_2731](/Users/cx_li/Documents/Github/digitalLogic_Lab/digital_logic_exp/lab6/report/IMG_2731.jpeg)

可见代码可以按照预期的方式工作。

## 错误现象及分析

暂未发现错误。

---

## 思考题

如何在显示器分辨率设置为1280×1024时，在屏幕中间显示640×480的图像？

- 图像显示模块中使用组合逻辑判断当前请求位置是否为中间640*480，是才输出像素颜色即可。

试试实现在屏幕上彩色字符（如图6.15所示）或实现类似电影Matrix开头的字符雨效果。

- 彩色字符让`get_charpix`模块根据位置计算不同颜色即可。

说说如何字屏幕上显示汉字（实验资源中HZK16S汉字16×16点阵字库文件）

- 把汉字点阵字库加载到`get_charpix`模块即可。

简述如何在图形界面中显示鼠标位置及其移动方向。

- 使用两个寄存器保存鼠标位置，绘制时判断每个像素点是否为鼠标，就绘制鼠标图标对应位置的像素颜色即可。
