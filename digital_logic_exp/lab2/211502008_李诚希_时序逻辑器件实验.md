# 数字逻辑与计算机组成实验 第二次实验 组合逻辑器件实验 实验报告

> 211502008 李诚希
>
> chengxili@smail.nju.edu.cn

## 1. 寄存器堆设计

### 整体设计

实验要求增加译码器和多路选择器，实现 32 个 32 位寄存器组成的寄存器堆。RA 和 RB 分别是读口 1和读口 2 的寄存器编号，RW 是写口的寄存器编号。

实现思路为：直接使用verilog提供的reg类型向量数组即可，然后在时钟上升沿时判断写使能是否为1，是则写入输入。

### 模块设计

直接使用verilog提供的reg类型向量数组即可，然后在时钟下降沿时判断写使能是否为1，是则写入输入。

代码如下：

```verilog
module regfile32(
   output  [31:0] busa,
   output  [31:0] busb,
   input [31:0] busw,
   input [4:0] ra,
   input [4:0] rb,
   input [4:0] rw,
   input clk, we
);
   reg [31:0] GPRs [0:31];
   wire [31:0] GPR_OUTPUT [0:31];
   genvar i; 
   generate
      for (i = 0; i < 32; i = i + 1)begin 
         assign GPR_OUTPUT[i] = GPRs[i]; 
      end 
   endgenerate 
   assign busa = GPR_OUTPUT[ra];
   assign busb = GPR_OUTPUT[rb];
   always@(negedge clk) begin
      GPRs[rw] <= (we == 1) ? ((rw == 0) ? 32'b0000000000000000 : busw): GPRs[rw];
   end
endmodule
```

为了方便在开发板上测试，编写另一个top模块，该模块将开发板的输入进行重复和拼接后送入一个`regfile32`，然后用按钮模拟时钟以便验证模块对于时钟信号的响应。代码如下：
```verilog

module regfile_top(
   output  [7:0] busa8,
   output  [7:0] busb8,
   input [3:0] busw,
   input [2:0] ra,
   input [2:0] rb,
   input [2:0] rw,
   input [1:0] rd_hi,
   input clk, we
   );
   wire [31:0] busa32;
   wire [31:0] busb32;
   wire [31:0] busw32;
   wire [4:0] ra32;
   wire [4:0] rb32;
   wire [4:0] rw32;
   genvar i;
   generate
      for(i = 0; i < 32; i = i + 1)begin
         assign busw32[i] = busw[i % 4];
      end
   endgenerate
   assign ra32[2:0] = ra;
   assign rb32[2:0] = rb;
   assign rw32[2:0] = rw;
   assign ra32[4:3] = rd_hi;
   assign rb32[4:3] = rd_hi;
   assign rw32[4:3] = rd_hi;
   assign busa8 = busa32[7:0];
   assign busb8 = busb32[7:0];
   regfile32 regfile32_check(.busa(busa32),.busb(busb32),.busw(busw32),.ra(ra32),.rb(rb32),.rw(rw32),.clk(clk),.we(we));
 
endmodule

```

### 仿真

仿真脚本直接给`regfile32`输入信号尝试不同的输入和选择和写使能信号：

```verilog
module regfile32_tb();
 wire [31:0] busa;
 wire [31:0] busb;
 reg [31:0] busw;
 reg [4:0] ra, rb,rw; 
 reg clk, we;
 integer i, errors;
  regfile32 d_register_inst(busa, busb, busw, ra, rb, rw,clk, we);
 always
  # 5 clk=~clk;
  initial begin
    $dumpfile("regfile32_tb.vcd");
    $dumpvars(0, regfile32_tb);
  clk=1;errors=0;#10
  for (i=0;i<=31;i=i+1)
   begin
       we=1;rw=i; busw=(1<<i);
       #10;
   end
  for (i=0;i<=31;i=i+1)
   begin
       we=0;rw=i;busw=32'hffffffff;
       #10;
   end
     for (i=0;i<=31;i=i+1)
     begin
     ra=i;rb=i;
     #10 if (busa!=(1<<i)) begin
            $display("Error: busa=%8h, 1<<i = %8h,i=%5b",   busa, 1<<i,i); 
            errors=errors+1; 
          end
         if (busb!=(1<<i)) begin 
             $display("Error: busb=%8h, 1<<i = %8h,i=%5b",   busb, 1<<i,i); 
             errors=errors+1; 
          end
     end
     $display("Test done, %d errors\n",errors);   
     $stop(1);
end

endmodule
```

为了方便使用iverilog编译和仿真我编写了如下Makefile:

```makefile
.PHONY : simulate_regfile32, simulate_encryption6b simulate clean

FILES = $(wildcard $(project_name)*.v)
vvp_files = $(wildcard *.vvp)
vcd_files = $(wildcard *.vcd)
sim_file = $(wildcard *_sim)

simulate:
	iverilog $(FILES) -o $(project_name)_sim.vvp
	vvp -n $(project_name)_sim.vvp -lxt2

clean:
	rm $(vvp_files) $(vcd_files) $(sim_file)
```

接着使用如下指令进行编译和仿真得到波形文件：

```bash
make simulate project_name=reg
```

使用GTKWave打开仿真生成的波形文件`regfile32_tb.vcd`：

![image-20240312143018667](/home/cx_li/.var/app/io.typora.Typora/config/Typora/typora-user-images/image-20240312143018667.png)

仿真结果表明该电路只写使能为1才会给rw对应位置写入，且只要有ra和rb，就可以正确读取响应位置的数据。

### 验证

使用实验框架提供额约束文件：

```verilog
set_property CLOCK_DEDICATED_ROUTE FALSE [get_nets clk_IBUF ];
set_property -dict { PACKAGE_PIN J15   IOSTANDARD LVCMOS33 } [get_ports { busw[0] }]; #IO_L24N_T3_RS0_15 Sch=sw[0]
set_property -dict { PACKAGE_PIN L16   IOSTANDARD LVCMOS33 } [get_ports { busw[1] }]; #IO_L3N_T0_DQS_EMCCLK_14 Sch=sw[1]
set_property -dict { PACKAGE_PIN M13   IOSTANDARD LVCMOS33 } [get_ports { busw[2] }]; #IO_L6N_T0_D08_VREF_14 Sch=sw[2]
set_property -dict { PACKAGE_PIN R15   IOSTANDARD LVCMOS33 } [get_ports { busw[3] }]; #IO_L13N_T2_MRCC_14 Sch=sw[3]
set_property -dict { PACKAGE_PIN R17   IOSTANDARD LVCMOS33 } [get_ports { ra[0] }]; #IO_L12N_T1_MRCC_14 Sch=sw[4]
set_property -dict { PACKAGE_PIN T18   IOSTANDARD LVCMOS33 } [get_ports { ra[1] }]; #IO_L7N_T1_D10_14 Sch=sw[5]
set_property -dict { PACKAGE_PIN U18   IOSTANDARD LVCMOS33 } [get_ports { ra[2] }]; #IO_L17N_T2_A13_D29_14 Sch=sw[6]
set_property -dict { PACKAGE_PIN R13   IOSTANDARD LVCMOS33 } [get_ports { rb[0] }]; #IO_L5N_T0_D07_14 Sch=sw[7]
set_property -dict { PACKAGE_PIN T8    IOSTANDARD LVCMOS33 } [get_ports { rb[1] }]; #IO_L24N_T3_34 Sch=sw[8]
set_property -dict { PACKAGE_PIN U8    IOSTANDARD LVCMOS33 } [get_ports { rb[2] }]; #IO_25_34 Sch=sw[9]
set_property -dict { PACKAGE_PIN R16   IOSTANDARD LVCMOS33 } [get_ports { rw[0] }]; #IO_L15P_T2_DQS_RDWR_B_14 Sch=sw[10]
set_property -dict { PACKAGE_PIN T13   IOSTANDARD LVCMOS33 } [get_ports { rw[1] }]; #IO_L23P_T3_A03_D19_14 Sch=sw[11]
set_property -dict { PACKAGE_PIN H6    IOSTANDARD LVCMOS33 } [get_ports { rw[2] }]; #IO_L24P_T3_35 Sch=sw[12]
set_property -dict { PACKAGE_PIN U12   IOSTANDARD LVCMOS33 } [get_ports { rd_hi[0] }]; #IO_L20P_T3_A08_D24_14 Sch=sw[13]
set_property -dict { PACKAGE_PIN U11   IOSTANDARD LVCMOS33 } [get_ports { rd_hi[1] }]; #IO_L19N_T3_A09_D25_VREF_14 Sch=sw[14]
set_property -dict { PACKAGE_PIN V10   IOSTANDARD LVCMOS33 } [get_ports { we }]; #IO_L21P_T3_DQS_14 Sch=sw[15]
set_property -dict { PACKAGE_PIN H17   IOSTANDARD LVCMOS33 } [get_ports { busa8[0] }]; #IO_L18P_T2_A24_15 Sch=led[0]
set_property -dict { PACKAGE_PIN K15   IOSTANDARD LVCMOS33 } [get_ports { busa8[1] }]; #IO_L24P_T3_RS1_15 Sch=led[1]
set_property -dict { PACKAGE_PIN J13   IOSTANDARD LVCMOS33 } [get_ports { busa8[2] }]; #IO_L17N_T2_A25_15 Sch=led[2]
set_property -dict { PACKAGE_PIN N14   IOSTANDARD LVCMOS33 } [get_ports { busa8[3] }]; #IO_L8P_T1_D11_14 Sch=led[3]
set_property -dict { PACKAGE_PIN R18   IOSTANDARD LVCMOS33 } [get_ports { busa8[4] }]; #IO_L7P_T1_D09_14 Sch=led[4]
set_property -dict { PACKAGE_PIN V17   IOSTANDARD LVCMOS33 } [get_ports { busa8[5] }]; #IO_L18N_T2_A11_D27_14 Sch=led[5]
set_property -dict { PACKAGE_PIN U17   IOSTANDARD LVCMOS33 } [get_ports { busa8[6] }]; #IO_L17P_T2_A14_D30_14 Sch=led[6]
set_property -dict { PACKAGE_PIN U16   IOSTANDARD LVCMOS33 } [get_ports { busa8[7] }]; #IO_L18P_T2_A12_D28_14 Sch=led[7]
set_property -dict { PACKAGE_PIN V16   IOSTANDARD LVCMOS33 } [get_ports { busb8[0] }]; #IO_L16N_T2_A15_D31_14 Sch=led[8]
set_property -dict { PACKAGE_PIN T15   IOSTANDARD LVCMOS33 } [get_ports { busb8[1] }]; #IO_L14N_T2_SRCC_14 Sch=led[9]
set_property -dict { PACKAGE_PIN U14   IOSTANDARD LVCMOS33 } [get_ports { busb8[2] }]; #IO_L22P_T3_A05_D21_14 Sch=led[10]
set_property -dict { PACKAGE_PIN T16   IOSTANDARD LVCMOS33 } [get_ports { busb8[3] }]; #IO_L15N_T2_DQS_DOUT_CSO_B_14 Sch=led[11]
set_property -dict { PACKAGE_PIN V15   IOSTANDARD LVCMOS33 } [get_ports { busb8[4] }]; #IO_L16P_T2_CSI_B_14 Sch=led[12]
set_property -dict { PACKAGE_PIN V14   IOSTANDARD LVCMOS33 } [get_ports { busb8[5] }]; #IO_L22N_T3_A04_D20_14 Sch=led[13]
set_property -dict { PACKAGE_PIN V12   IOSTANDARD LVCMOS33 } [get_ports { busb8[6] }]; #IO_L20N_T3_A07_D23_14 Sch=led[14]
set_property -dict { PACKAGE_PIN V11   IOSTANDARD LVCMOS33 } [get_ports { busb8[7] }]; #IO_L21N_T3_DQS_A06_D22_14 Sch=led[15]
```

使用vivado对代码进行综合并生成比特流，烧录进开发板：

![image-20240312143759580](/home/cx_li/.var/app/io.typora.Typora/config/Typora/typora-user-images/image-20240312143759580.png)

烧录之后在开发板上进行实验：

![537cb875077c391ce6e09be032866c0b](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/537cb875077c391ce6e09be032866c0b.jpg)

![7948864d16d7bd3eae9bc5942a26a278](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/7948864d16d7bd3eae9bc5942a26a278.jpg)

![da24f63ee069de3b4de184d1af05e90e](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/da24f63ee069de3b4de184d1af05e90e.jpg)

可见只有被选择通路才能在时钟下降沿写入，其他情况均不会写入。

### 错误现象及分析

实验中没有遇到错误。

## 2. 比特流加密实验

### 整体设计

该实验目标是利用线性移位寄存器 LFSR 产生的随机比特流来对字符串进行加密和解密。

实现思路为：先编写一个模块用于对于给定的seed生成随机比特串，然后再用这个比特串异或输入内容即可。

### 模块设计

LFSR使用反馈方程x64=x4⊕x3⊕x1⊕x0，在点击按钮时会重置寄存器中的内容并将seed放入寄存器，然后每个按钮按下周期将所有寄存器移动一位，空出来的位置放入使用反馈方程生成的比特。代码如下：

```verilog

module lfsr(              //64位线性移位寄存器
	output reg [63:0] dout,
    input  [63:0]  seed,
	input  clk,
	input  load
	);
    reg new_bit = 0;
    reg has_loaded = 0;
    always @(posedge clk) begin
        if(load == 1)begin
            dout <= seed;
            has_loaded <= 1;
        end
        else if(has_loaded == 1)begin
            new_bit <= dout[0] ^ dout[1] ^ dout[2] ^ dout[3];
            /*
            ```python3
            for i in range(0, 63):
                print("dout[{}] <= dout[{}];".format(str(i), str(i+1)))
```
            */
            dout[0] <= dout[1];
            dout[1] <= dout[2];
            dout[2] <= dout[3];
            dout[3] <= dout[4];
            dout[4] <= dout[5];
            dout[5] <= dout[6];
            dout[6] <= dout[7];
            dout[7] <= dout[8];
            dout[8] <= dout[9];
            dout[9] <= dout[10];
            dout[10] <= dout[11];
            dout[11] <= dout[12];
            dout[12] <= dout[13];
            dout[13] <= dout[14];
            dout[14] <= dout[15];
            dout[15] <= dout[16];
            dout[16] <= dout[17];
            dout[17] <= dout[18];
            dout[18] <= dout[19];
            dout[19] <= dout[20];
            dout[20] <= dout[21];
            dout[21] <= dout[22];
            dout[22] <= dout[23];
            dout[23] <= dout[24];
            dout[24] <= dout[25];
            dout[25] <= dout[26];
            dout[26] <= dout[27];
            dout[27] <= dout[28];
            dout[28] <= dout[29];
            dout[29] <= dout[30];
            dout[30] <= dout[31];
            dout[31] <= dout[32];
            dout[32] <= dout[33];
            dout[33] <= dout[34];
            dout[34] <= dout[35];
            dout[35] <= dout[36];
            dout[36] <= dout[37];
            dout[37] <= dout[38];
            dout[38] <= dout[39];
            dout[39] <= dout[40];
            dout[40] <= dout[41];
            dout[41] <= dout[42];
            dout[42] <= dout[43];
            dout[43] <= dout[44];
            dout[44] <= dout[45];
            dout[45] <= dout[46];
            dout[46] <= dout[47];
            dout[47] <= dout[48];
            dout[48] <= dout[49];
            dout[49] <= dout[50];
            dout[50] <= dout[51];
            dout[51] <= dout[52];
            dout[52] <= dout[53];
            dout[53] <= dout[54];
            dout[54] <= dout[55];
            dout[55] <= dout[56];
            dout[56] <= dout[57];
            dout[57] <= dout[58];
            dout[58] <= dout[59];
            dout[59] <= dout[60];
            dout[60] <= dout[61];
            dout[61] <= dout[62];
            dout[62] <= dout[63];
            dout[63] <= new_bit;
        end else begin
            dout <= 0;
        end
    end
endmodule
```

然后再在加密模块中调用这个LFSR，每次读取其输出并与信息异或即可。代码如下：

```verilog
module encryption6b(
    output [7:0] dataout,    //输出加密或解密后的8比特ASCII数据。
    output reg ready,       //输出有效标识，高电平说明输出有效，第6周期高电平
    output [5:0] key,       //输出6位加密码
    input clk,             // 时钟信号，上升沿有效
    input load,            //载入seed指示，高电平有效
    input [7:0] datain       //输入数据的8比特ASCII码。
);
    wire  [63:0] seed=64'ha845fd7183ad75c4;       //初始64比特seed=64'ha845fd7183ad75c4
//add your code here
    reg [7:0]datain_R = 0;
    wire [63:0]lfsr_out;
    reg [2:0] counter = 3'b000;
    lfsr L(
        .dout(lfsr_out),
        .seed(seed),
        .clk(clk),
        .load(load)
    );
    assign key = lfsr_out[63:58];
    assign dataout[7] = datain_R[7]; 
    assign dataout[6] = datain_R[6]; 
    assign dataout[5] = datain_R[5] ^ lfsr_out[63]; 
    assign dataout[4] = datain_R[4] ^ lfsr_out[62]; 
    assign dataout[3] = datain_R[3] ^ lfsr_out[61]; 
    assign dataout[2] = datain_R[2] ^ lfsr_out[60]; 
    assign dataout[1] = datain_R[1] ^ lfsr_out[59]; 
    assign dataout[0] = datain_R[0] ^ lfsr_out[58]; 
    always @(posedge clk) begin
        if(load == 1)begin
            datain_R <= datain;
            counter <= 6'b000;
            ready <= 1'b0;
        end else begin
            if(counter == 3'b101)begin
                counter <= 3'b000;
                ready <= 1'b1;
            end else begin
                counter <= counter + 1;
                ready <= 1'b0;
            end
        end
    end
endmodule
```

### 仿真

仿真脚本先关闭load运行几个时钟，然后打开load运行两个时钟再关闭load，然后又运行若干个时钟：

```verilog
`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 2023/09/17 16:34:51
// Design Name: 
// Module Name: encryption6b_tb
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module encryption6b_tb(    );
// add your code

    wire [7:0] dataout;
    wire ready_w;
    wire [5:0] key_w;
    reg [5:0] key;
    assign key_w = key;
    wire clk_w;
    reg clk;
    assign clk_w = clk;
    wire load_w;
    reg load;
    assign load_w = load;
    wire [7:0] datain_w;
    reg [7:0] datain;
    assign datain_w = datain;

    encryption6b encryption6b_test(
        .dataout(dataout),
        .ready(ready_w),
        .key(key_w),
        .clk(clk_w),
        .load(load_w),
        .datain(datain_w)
    );
    integer i;
    initial begin
        $dumpfile("encryption6b_tb.vcd");
        $dumpvars(0, encryption6b_tb);
        clk = 0;
        load = 0;
        datain = 8'b10101010;
        key = 8'b10010100;
        for(i = 0; i < 40; i = i + 1)begin
            clk = ~clk;
            #2;
        end
        clk = 0;
        load = 1;
        #2;
        clk = 1;
        #2;
        clk = 0;
        #2;
        clk = 1;
        #2;
        clk = 0;
        #2;
        load = 0;
        #2;
        for(i = 0; i < 40; i = i + 1)begin
            clk = ~clk;
            #2;
        end
    end
endmodule

```

使用上述makefile脚本和如下指令调用iverilog进编译和行仿真得到波形文件：

```bash
make simulate project_name=reg
```

使用GTKWave打开仿真生成的波形文件`encryption6b_tb.vcd`（此时输入为10101010）：

![image-20240312163320726](/home/cx_li/.var/app/io.typora.Typora/config/Typora/typora-user-images/image-20240312163320726.png)

可以看到仿真结果符合预期，即没有load过且load为0时始终不变，load为1且时钟上升时写入，此后load为0时随着时钟运行。

下图为使用仿真第一次ready时的输出信号（10110100）作为输入得到的仿真：

![image-20240312163612631](/home/cx_li/.var/app/io.typora.Typora/config/Typora/typora-user-images/image-20240312163612631.png)

可见同一段内容可以被加密然后解密回复相同的比特串（10101010）。

仿真结果符合预期。

### 验证

使用实验框架提供的约束代码：
``` verilog
set_property CLOCK_DEDICATED_ROUTE FALSE [get_nets clk_IBUF ];
set_property -dict { PACKAGE_PIN J15   IOSTANDARD LVCMOS33 } [get_ports { datain[0] }]; #IO_L24N_T3_RS0_15 Sch=sw[0]
set_property -dict { PACKAGE_PIN L16   IOSTANDARD LVCMOS33 } [get_ports { datain[1] }]; #IO_L3N_T0_DQS_EMCCLK_14 Sch=sw[1]
set_property -dict { PACKAGE_PIN M13   IOSTANDARD LVCMOS33 } [get_ports { datain[2] }]; #IO_L6N_T0_D08_VREF_14 Sch=sw[2]
set_property -dict { PACKAGE_PIN R15   IOSTANDARD LVCMOS33 } [get_ports { datain[3] }]; #IO_L13N_T2_MRCC_14 Sch=sw[3]
set_property -dict { PACKAGE_PIN R17   IOSTANDARD LVCMOS33 } [get_ports { datain[4] }]; #IO_L12N_T1_MRCC_14 Sch=sw[4]
set_property -dict { PACKAGE_PIN T18   IOSTANDARD LVCMOS33 } [get_ports { datain[5] }]; #IO_L7N_T1_D10_14 Sch=sw[5]
set_property -dict { PACKAGE_PIN U18   IOSTANDARD LVCMOS33 } [get_ports { datain[6] }]; #IO_L17N_T2_A13_D29_14 Sch=sw[6]
set_property -dict { PACKAGE_PIN R13   IOSTANDARD LVCMOS33 } [get_ports { datain[7] }]; #IO_L5N_T0_D07_14 Sch=sw[7]
set_property -dict { PACKAGE_PIN V10   IOSTANDARD LVCMOS33 } [get_ports { load }]; #IO_L21P_T3_DQS_14 Sch=sw[15]
set_property -dict { PACKAGE_PIN H17   IOSTANDARD LVCMOS33 } [get_ports { dataout[0] }]; #IO_L18P_T2_A24_15 Sch=led[0]
set_property -dict { PACKAGE_PIN K15   IOSTANDARD LVCMOS33 } [get_ports { dataout[1] }]; #IO_L24P_T3_RS1_15 Sch=led[1]
set_property -dict { PACKAGE_PIN J13   IOSTANDARD LVCMOS33 } [get_ports { dataout[2] }]; #IO_L17N_T2_A25_15 Sch=led[2]
set_property -dict { PACKAGE_PIN N14   IOSTANDARD LVCMOS33 } [get_ports { dataout[3] }]; #IO_L8P_T1_D11_14 Sch=led[3]
set_property -dict { PACKAGE_PIN R18   IOSTANDARD LVCMOS33 } [get_ports { dataout[4] }]; #IO_L7P_T1_D09_14 Sch=led[4]
set_property -dict { PACKAGE_PIN V17   IOSTANDARD LVCMOS33 } [get_ports { dataout[5] }]; #IO_L18N_T2_A11_D27_14 Sch=led[5]
set_property -dict { PACKAGE_PIN U17   IOSTANDARD LVCMOS33 } [get_ports { dataout[6] }]; #IO_L17P_T2_A14_D30_14 Sch=led[6]
set_property -dict { PACKAGE_PIN U16   IOSTANDARD LVCMOS33 } [get_ports { dataout[7] }]; #IO_L18P_T2_A12_D28_14 Sch=led[7]
set_property -dict { PACKAGE_PIN T15   IOSTANDARD LVCMOS33 } [get_ports { key[0] }]; #IO_L14N_T2_SRCC_14 Sch=led[9]
set_property -dict { PACKAGE_PIN U14   IOSTANDARD LVCMOS33 } [get_ports { key[1] }]; #IO_L22P_T3_A05_D21_14 Sch=led[10]
set_property -dict { PACKAGE_PIN T16   IOSTANDARD LVCMOS33 } [get_ports { key[2] }]; #IO_L15N_T2_DQS_DOUT_CSO_B_14 Sch=led[11]
set_property -dict { PACKAGE_PIN V15   IOSTANDARD LVCMOS33 } [get_ports { key[3] }]; #IO_L16P_T2_CSI_B_14 Sch=led[12]
set_property -dict { PACKAGE_PIN V14   IOSTANDARD LVCMOS33 } [get_ports { key[4] }]; #IO_L22N_T3_A04_D20_14 Sch=led[13]
set_property -dict { PACKAGE_PIN V12   IOSTANDARD LVCMOS33 } [get_ports { key[5] }]; #IO_L20N_T3_A07_D23_14 Sch=led[14]
set_property -dict { PACKAGE_PIN V11   IOSTANDARD LVCMOS33 } [get_ports { ready }]; #IO_L21N_T3_DQS_A06_D22_14 Sch=led[15]
```

使用vivado对代码进行综合并生成比特流，烧录进开发板：

![image-20240312164308240](/home/cx_li/.var/app/io.typora.Typora/config/Typora/typora-user-images/image-20240312164308240.png)

烧录之后在开发板上进行实验验证：

刚开机时输出0:

![a0673fe540ee9b661e55986c9165379c](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/02/a0673fe540ee9b661e55986c9165379c.jpg)

以全0作为输入：

![4ab02ba83b302a6da26cdb2808a1d7aa](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/02/4ab02ba83b302a6da26cdb2808a1d7aa.jpg)

ready点亮，得到加密结果：

![9b9ff8196586d53cab3fae5dd4e5d77e](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/02/9b9ff8196586d53cab3fae5dd4e5d77e.jpg)

输入加密结果：

![93198b072b9bdb960b3c100d7cb16565](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/02/93198b072b9bdb960b3c100d7cb16565.jpg)

运行若干个时钟，ready点亮，解密得到加密前的输入：

![a4b937fdd0a6d968ee85ff044e076d1f](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/02/a4b937fdd0a6d968ee85ff044e076d1f.jpg)

可见开发板可以按照预期工作，即，可以正常加解密

### 错误现象及分析

最初没有给寄存器设置初值导致仿真报x。

## 3. 数字时钟实验

### 整体设计

基于计数器和时钟发生器的系统，计数器用于计算时钟的时间，为时、分、秒三个计数器。时钟发生器产生固定频率的时钟信号，用于驱动计数器的计数。七段数码管用于显示时钟的时间。具备以下功能：数字时钟、倒计时、计时器和闹钟。

### 模块设计

该设计由若干个模块组成：

1. `chose8to1_1` 模块：这是一个8到1的多路选择器，根据选择信号 `chose_sig` 的值，从8个输入信号 `I0` 到 `I7` 中选择一个输出到 `OUT`。
2. `chose8to1` 模块：这个模块内部实例化了 `chose8to1_1` 模块7次，用于处理4位的输入 `I0` 到 `I7`，并将结果输出到 `OUT`。
3. `decoder_seg` 模块：这是一个七段显示解码器，将4位的输入 `I` 解码为8位的输出 `seg`，用于驱动七段显示器的各个段，显示数字0到9以及字母A到F。
4. `decoder_3to8` 模块：这是一个3到8的解码器，将3位的输入 `INPUT` 解码为8位的输出 `OUT`，用于选择七段显示器的一个段。
5. `display` 模块：这个模块用于控制一个七段显示器，它接收时钟信号 `clk` 和8位的数据输入 `DATA0` 到 `DATA7`，以及一个用于选择当前显示位的 `points` 输入，输出到七段显示器的 `SEG` 和选择信号 `choseLED`。
6. `blinker` 模块：这个模块用于控制一个闪烁器，它接收时钟信号 `clk` 和一个用于选择闪烁位的 `blinker_addr` 输入，以及8位的数据输入 `DATA0` 到 `DATA7`，输出到 `OUT_DATA0` 到 `OUT_DATA7`。
7. `trans_1224` 模块：这个模块用于将24小时制的时间转换为12小时制，同时处理上午和下午的显示，以及将时间转换为七段显示器所需的格式。
8. `clock` 模块：这是一个时钟模块，用于模拟时钟的运行，包括小时 `H`、分钟 `M`、秒 `S` 和毫秒 `tms` 的计数，以及用于设置和显示的控制信号。
9. `BCD2INT` 模块：这个模块将BCD编码的小时和分钟转换为整数，用于内部时间的计算和比较。
10. `alarm` 模块：这是一个闹钟模块，用于设置和显示多个闹钟时间，以及控制闹钟的闪烁指示。
11. `stopwatch` 模块：这是一个秒表模块，用于计时，包括开始、停止和重置功能。
12. `time_m` 模块：这个模块用于计算两个时间点之间的差值，输出小时 `cH`、分钟 `cM` 和秒 `cS`。
13. `timers` 模块：这是一个多功能定时器模块。
14. `DigitalTimer` 模块：这是顶层模块，它将上述所有模块整合在一起，实现了数字定时器的所有功能，包括时间显示、闹钟设置、秒表计时等。它接收外部输入信号，如时钟 `clk`、复位 `RST`、开始/暂停 `StartOrPause`、读取参数 `ReadPara`、时间格式 `TimeFormat`、模式选择 `mode`、闹钟编号 `AlarmNo`、高位和低位数据 `data_h` 和 `data_l`，输出包括下午指示 `Afternoon`、整点报时 `TimeKeeper`、闹钟显示 `AlarmDisplay`、七段显示 `segs` 和阳极选择信号 `an`。

模块间链接方式如图：

![dfdee4baf5d9e947eda22b4d20482555](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/dfdee4baf5d9e947eda22b4d20482555.jpg)

代码如下：

``` verilog
`timescale 1ns / 1ps

`define seg_0 (~I[0]&~I[1]&~I[2]&~I[3])
`define seg_1 (~I[0]&~I[1]&~I[2]&I[3])
`define seg_2 (~I[0]&~I[1]&I[2]&~I[3])
`define seg_3 (~I[0]&~I[1]&I[2]&I[3])
`define seg_4 (~I[0]&I[1]&~I[2]&~I[3])
`define seg_5 (~I[0]&I[1]&~I[2]&I[3])
`define seg_6 (~I[0]&I[1]&I[2]&~I[3])
`define seg_7 (~I[0]&I[1]&I[2]&I[3])
`define seg_8 (I[0]&~I[1]&~I[2]&~I[3])
`define seg_9 (I[0]&~I[1]&~I[2]&I[3])
`define seg_A (I[0]&~I[1]&I[2]&~I[3])
`define seg_B (I[0]&~I[1]&I[2]&I[3])
`define seg_C (I[0]&I[1]&~I[2]&~I[3])
`define seg_D (I[0]&I[1]&~I[2]&I[3])
`define seg_E (I[0]&I[1]&I[2]&~I[3])
`define seg_F (I[0]&I[1]&I[2]&I[3])

module chose8to1_1(
        input I0,
        input I1,
        input I2,
        input I3,
        input I4,
        input I5,
        input I6,
        input I7,
        output OUT,
        input [2:0] chose_sig
    );
    assign OUT = (chose_sig == 0 & I0) |
            (chose_sig == 1 & I1) | 
            (chose_sig == 2 & I2) | 
            (chose_sig == 3 & I3) | 
            (chose_sig == 4 & I4) | 
            (chose_sig == 5 & I5) | 
            (chose_sig == 6 & I6) | 
            (chose_sig == 7 & I7);
endmodule
module chose8to1(
        input [3:0] I0,
        input [3:0] I1,
        input [3:0] I2,
        input [3:0] I3,
        input [3:0] I4,
        input [3:0] I5,
        input [3:0] I6,
        input [3:0] I7,
        output [3:0] OUT,
        input [2:0] C
    );
    genvar i;
    generate
        for(i = 0; i <= 3; i = i + 1)begin
            chose8to1_1 chose_blk(
                .I0(I0[i]),
                .I1(I1[i]),
                .I2(I2[i]),
                .I3(I3[i]),
                .I4(I4[i]),
                .I5(I5[i]),
                .I6(I6[i]),
                .I7(I7[i]),
                .OUT(OUT[3 - i]),
                .chose_sig(C)
            );
        end
    endgenerate
endmodule
// set F to blank
module decoder_seg(
                input [3:0] I,
                input point,
                output [7:0] seg
            );
    assign seg[0] = `seg_1 | `seg_4 | `seg_B | `seg_D | `seg_F;
    assign seg[1] = `seg_5 | `seg_6 | `seg_B | `seg_C | `seg_E | `seg_F;
    assign seg[2] = `seg_2 | `seg_C | `seg_E | `seg_F;
    assign seg[3] = `seg_1 | `seg_4 | `seg_7 | `seg_A | `seg_F;
    assign seg[4] = `seg_1 | `seg_3 | `seg_4 | `seg_5 | `seg_7 | `seg_9 | `seg_F;
    assign seg[5] = `seg_1 | `seg_2 | `seg_3 | `seg_7 | `seg_D | `seg_F;
    assign seg[6] = `seg_0 | `seg_1 | `seg_7 | `seg_C | `seg_F;
    assign seg[7] = point;
endmodule

module decoder_3to8(
            input [2:0] INPUT,
            output [7:0] OUT
        );
    wire [3:0] I;
    assign I = {INPUT[0], INPUT[1], INPUT[2], 1'b0};
    assign OUT[0] = ~`seg_0;
    assign OUT[1] = ~`seg_1;
    assign OUT[2] = ~`seg_2;
    assign OUT[3] = ~`seg_3;
    assign OUT[4] = ~`seg_4;
    assign OUT[5] = ~`seg_5;
    assign OUT[6] = ~`seg_6;
    assign OUT[7] = ~`seg_7;
endmodule

module display(
    input clk,
    input [3:0]DATA0,
    input [3:0]DATA1,
    input [3:0]DATA2,
    input [3:0]DATA3,
    input [3:0]DATA4,
    input [3:0]DATA5,
    input [3:0]DATA6,
    input [3:0]DATA7,
    input [7:0]points,
    output [7:0] SEG,
    output [7:0] choseLED
);
    wire [3:0]BUS;
    wire [2:0]choseLED_W;
    reg [2:0]c_REG;
    wire [2:0]CREG_w;
    assign CREG_w = c_REG;
    chose8to1 OUT_SUB(
        .I0(DATA0),
        .I1(DATA1),
        .I2(DATA2),
        .I3(DATA3),
        .I4(DATA4),
        .I5(DATA5),
        .I6(DATA6),
        .I7(DATA7),
        .OUT(BUS),
        .C(CREG_w)
    );
    decoder_3to8 C_LED( 
        .INPUT(3'b111 - CREG_w),
        .OUT(choseLED)
    );
    decoder_seg num2seg(
        .I(BUS),
        .point(points[3'b111 - CREG_w]),
        .seg(SEG)
    );
    reg [31:0] counter = 31'd0;
    always@(posedge clk) begin : main
        counter <= counter + 1;
        c_REG <= (counter/10000) % 8;
        if(counter == 100000000)begin
           counter <= 0;
        end
    end
endmodule

module blinker(
    input clk,
    input [7:0]blinker_addr,
    input [3:0]DATA0,
    input [3:0]DATA1,
    input [3:0]DATA2,
    input [3:0]DATA3,
    input [3:0]DATA4,
    input [3:0]DATA5,
    input [3:0]DATA6,
    input [3:0]DATA7,
    output [3:0]OUT_DATA0,
    output [3:0]OUT_DATA1,
    output [3:0]OUT_DATA2,
    output [3:0]OUT_DATA3,
    output [3:0]OUT_DATA4,
    output [3:0]OUT_DATA5,
    output [3:0]OUT_DATA6,
    output [3:0]OUT_DATA7
);
    reg [31:0]cnt = 0;
    assign OUT_DATA0 = (blinker_addr[7] == 1 && cnt > 50000000) ? 4'b1111 : DATA0;
    assign OUT_DATA1 = (blinker_addr[6] == 1 && cnt > 50000000) ? 4'b1111 : DATA1;
    assign OUT_DATA2 = (blinker_addr[5] == 1 && cnt > 50000000) ? 4'b1111 : DATA2;
    assign OUT_DATA3 = (blinker_addr[4] == 1 && cnt > 50000000) ? 4'b1111 : DATA3;
    assign OUT_DATA4 = (blinker_addr[3] == 1 && cnt > 50000000) ? 4'b1111 : DATA4;
    assign OUT_DATA5 = (blinker_addr[2] == 1 && cnt > 50000000) ? 4'b1111 : DATA5;
    assign OUT_DATA6 = (blinker_addr[1] == 1 && cnt > 50000000) ? 4'b1111 : DATA6;
    assign OUT_DATA7 = (blinker_addr[0] == 1 && cnt > 50000000) ? 4'b1111 : DATA7;
    always @(posedge clk) begin
        cnt <= (cnt + 1) % 100000000;
    end
endmodule

module trans_1224(
    input is_12,
    input [6:0]H,
    input [6:0]M,
    input [6:0]S,
    input [6:0]ms,
    output afternoon_led,
    output [3:0]DATA0,
    output [3:0]DATA1,
    output [3:0]DATA2,
    output [3:0]DATA3,
    output [3:0]DATA4,
    output [3:0]DATA5,
    output [3:0]DATA6,
    output [3:0]DATA7,
    output [7:0]points
);
    wire [6:0]H_1224;
    assign afternoon_led = (is_12 == 1'b1 && H > 12) ? 1 : 0;
    assign H_1224 = (is_12 == 1'b1 && H > 12) ? H - 12 : H;
    assign DATA0 = H_1224/10;
    assign DATA1 = H_1224%10;
    assign DATA2 = M/10;
    assign DATA3 = M%10;
    assign DATA4 = S/10;
    assign DATA5 = S%10;
    assign DATA6 = ms/10;
    assign DATA7 = ms%10;
    assign points = 8'b10101011;
endmodule

module clock(
    input clk,
    input [6:0]setting_num,
    input set,
    input [1:0]setting_mode,
    input enable,
    output [6:0]H,
    output [6:0]M,
    output [6:0]S,
    output [6:0]tms,
    output [7:0]blink_chose,
    output [2:0]TimeKeeper
);
    reg [31:0]counter;
    reg [6:0]rS = 0;
    reg [6:0]rM = 0;
    reg [6:0]rH = 0;
    reg [6:0]rTMS = 0;
    reg [7:0]blink_r;
    reg [2:0]TimeKeeper_R;
    assign TimeKeeper = TimeKeeper_R;
    assign tms = rTMS;
    assign S = rS;
    assign M = rM;
    assign H = rH;
    assign blink_chose = blink_r;
    reg is_setting = 0, has_setted = 0;
    always @(posedge clk) begin
        if(((setting_mode == 2'b00 || has_setted == 1) && is_setting == 0) || enable == 0)begin
            TimeKeeper_R = (rM == 0 && (rS == 0 || rS == 2 || rS == 4 || rS == 6 || rS == 8)) ? 4'b1111 : 4'b0000;
            if(setting_mode == 2'b00)begin
                has_setted <= 0;
            end
            if(counter == 999999)begin
                counter <= 0;
                if(rTMS == 99)begin
                    if(rS == 59)begin
                        if(rM == 59)begin
                            rH = (rH + 1) % 24;
                        end
                        rM = (rM + 1) % 60;
                    end
                    rS = (rS + 1) % 60;
                end
                rTMS <= (rTMS + 1) % 100;
            end else begin
                counter <= counter + 1;
            end
        end
        else begin
            if(has_setted == 0)begin
                is_setting <= 1;
            end
            if(set == 1)begin
                blink_r <= 8'b00000000;
                has_setted = 1;
                is_setting = 0;
            end
            if(setting_mode == 2'b01 && has_setted == 0)begin
                blink_r <= 8'b00001100;
                rS <= setting_num % 60;//(setting_num > 7'd59) ? 59 : setting_num;
            end
            if(setting_mode == 2'b10 & has_setted == 0)begin
                blink_r <= 8'b00110000;
                rM <= setting_num % 60;//(setting_num > 7'd59) ? 59 : setting_num;
            end
            if(setting_mode == 2'b11 && has_setted == 0)begin
                blink_r <= 8'b11000000;
                rH <= setting_num % 24;//(setting_num > 7'd23) ? 23 : setting_num;
            end
            if(setting_mode == 2'b00 && has_setted == 0)begin
                blink_r <= 8'b11111111;
            end
        end
    end
endmodule

module BCD2INT(
    input [3:0] data_h,//���ò�����λ��ʹ�� BCD ���ʾ
    input [3:0] data_l,//���ò�����λ��ʹ�� BCD ���ʾ
    output [6:0] data_out
);
    assign data_out = 10 * ((data_h > 9) ? 9 : data_h) + ((data_l > 9) ? 9 : data_l);
endmodule

module alarm(
    input clk,
    input [6:0]now_H,
    input [6:0]now_M,
    input [6:0]now_S,
    input [6:0]setting_num,
    input enable,
    input [1:0]AlarmNo,
    input set,
    input [1:0]setting_mode,
    output [6:0]setted_H,
    output [6:0]setted_M,
    output [6:0]setted_S,
    output [7:0]blink_chose,
    output [2:0]AlarmDisplay
);
    reg [6:0]alram_H[0:3];
    reg [6:0]alram_M[0:3];
    reg [6:0]alram_S[0:3];
    reg [2:0]alram_LED;
    reg [31:0]alram_start = 0;
    reg is_alraming, red_LED;
    reg [7:0]blink_r;
    assign blink_chose = blink_r;
    assign AlarmDisplay = alram_LED;
    assign setted_H = alram_H[AlarmNo];
    assign setted_M = alram_M[AlarmNo];
    assign setted_S = alram_S[AlarmNo];
    wire at_time;
    assign AlarmDisplay[0] = red_LED;
    assign at_time =
                 ((now_H == alram_H[0] && now_M == alram_M[0] && now_S == alram_S[0]) || 
                 (now_H == alram_H[1] && now_M == alram_M[1] && now_S == alram_S[1]) || 
                 (now_H == alram_H[2] && now_M == alram_M[2] && now_S == alram_S[2]) || 
                 (now_H == alram_H[3] && now_M == alram_M[3] && now_S == alram_S[3])  == 1 )? 1 : 0;
    reg has_setted, is_setting;
    always@(posedge clk)begin
        
        if(is_alraming == 0)begin
            is_alraming <= at_time;
            alram_start <= (at_time == 1) ? 0 : 100000000;
        end
        if(is_alraming == 1)begin
            alram_start <= alram_start + 1;
        end
        red_LED <= ((alram_start / 100000000) % 2 == 0) ? 1 : 0;
        if(alram_start >= 1000000000)begin
            is_alraming <= 0;
            alram_start <= 100000000;
            red_LED <= 0;
        end
        
        if(enable == 1)begin
            if(setting_mode == 2'b00 && has_setted == 1)begin
                has_setted <= 0;
            end
            if(setting_mode != 2'b00 && has_setted == 0)begin
                is_setting <= 1;
            end
            if(is_setting == 1)begin
                if(set == 1)begin
                    blink_r <= 8'b00000000;
                    has_setted = 1;
                    is_setting = 0;
                end
                if(setting_mode == 2'b01 && has_setted == 0)begin
                    blink_r <= 8'b00001100;
                    alram_S[AlarmNo] <= setting_num % 60;//(setting_num > 7'd59) ? 59 : setting_num;
                end
                if(setting_mode == 2'b10 & has_setted == 0)begin
                    blink_r <= 8'b00110000;
                    alram_M[AlarmNo] <= setting_num % 60;//(setting_num > 7'd59) ? 59 : setting_num;
                end
                if(setting_mode == 2'b11 && has_setted == 0)begin
                    blink_r <= 8'b11000000;
                    alram_H[AlarmNo] <= setting_num % 24;//(setting_num > 7'd23) ? 23 : setting_num;
                end
                if(setting_mode == 2'b00 && has_setted == 0)begin
                    blink_r <= 8'b11111111;
                end
            end
        end
    end
endmodule

module stopwatch(
    input srart_stop,
    input reset,
    input enable,
    input clk,
    output [6:0]H,
    output [6:0]M,
    output [6:0]S,
    output [6:0]tms,
    output [7:0]blink_chose
);
    assign blink_chose = 8'b00000000;
    reg [63:0]counter = 0;
    reg is_stop = 1;
    reg is_pushdown = 0;
    reg is_rst_pushdown = 0;
    reg [6:0]rS = 0;
    reg [6:0]rM = 0;
    reg [6:0]rH = 0;
    reg [6:0]rTMS = 0;
    assign H = rH;
    assign M = rM;
    assign S = rS;
    assign tms = rTMS;
    always@(posedge clk)begin
        if(enable == 1)begin
            if(srart_stop == 1 && is_pushdown == 0)begin
                is_stop = ~is_stop;
                is_pushdown <= 1;
            end
            if(reset == 1 && is_rst_pushdown == 0)begin
                counter <= 0;
                rTMS <= 0;
                rS <= 0;
                rM <= 0;
                rH <= 0;
                is_rst_pushdown <= 1;
            end
        end
        if(srart_stop == 0)begin
            is_pushdown <= 0;
        end
        if(reset == 0)begin
            is_rst_pushdown <= 0;
        end
        if(is_stop == 0 && !(reset == 1 && is_rst_pushdown == 0))begin
            counter <= counter + 1;//1s = 100000000
            if(counter == 999999)begin
                counter <= 0;
                if(rTMS == 99)begin
                    if(rS == 59)begin
                        if(rM == 59)begin
                            rH = (rH + 1) % 24;
                        end
                        rM = (rM + 1) % 60;
                    end
                    rS = (rS + 1) % 60;
                end
                rTMS <= (rTMS + 1) % 100;
            end else begin
                counter <= counter + 1;
            end
        end
    end
endmodule

//a - b
module time_m(
    input [6:0]aH,
    input [6:0]aM,
    input [6:0]aS,
    input [6:0]bH,
    input [6:0]bM,
    input [6:0]bS,
    output [6:0]cH,
    output [6:0]cM,
    output [6:0]cS
);
    wire S2M, M2H;
    assign S2M = (aS >= bS) ? 0 : 1;
    assign M2H = (aM >= (bM + S2M)) ? 0 : 1;
    assign cS = (aS >= bS) ? (aS - bS) : (aS + 60 - bS);
    assign cM = (M2H) ? (aM + 60 - (bM + S2M)) : (aM - (bM + S2M));
    assign cH = aH - (bH + M2H);
endmodule

module timers(
    input clk,
    input [1:0]setting_mode,
    input [6:0]setting_num,
    input start_stop,
    input enable,
    input reset,
    input set,
    output [7:0]blink_chose,
    output [6:0]H,
    output [6:0]M,
    output [6:0]S,
    output [6:0]tms,
    output red_LED
);
    reg [6:0] max_H = 0;
    reg [6:0] max_M = 1;
    reg [6:0] max_S = 0;
    reg [6:0] rH = 0;
    reg [6:0] rM = 0;
    reg [6:0] rS = 0;
    reg [6:0] rTMS;
    reg is_setting = 0, has_setted = 0, is_running = 1, is_stop = 1;
    reg has_pushdown_stop = 0;
    reg [63:0] counter = 0;
    reg [63:0] tms_counter = 0;
    reg alram_LED = 0;
    assign red_LED = alram_LED;
    reg [7:0]blink_r;
    assign blink_chose = blink_r;
    time_m res(
        .aH(max_H),
        .aM(max_M),
        .aS(max_S),
        .bH(rH),
        .bM(rM),
        .bS(rS),
        .cH(H),
        .cM(M),
        .cS(S)
    );
    assign tms = (99 - rTMS);
    reg is_stop_pushdown = 0, is_rst_pushdown = 1;
    always@(posedge clk)begin
        if(is_running == 0)begin
            rTMS <= 99;
            rH <= 0;
            rM <= 0;
            rS <= 0;
            if(enable == 1)begin
                if(set == 1)begin
                    blink_r <= 8'b00000000;
                    has_setted <= 1;
                    is_running <= 1;
                    is_stop <= 1;
                end
                if(setting_mode == 2'b01 && has_setted == 0)begin
                    blink_r <= 8'b00001100;
                    max_S <= setting_num % 60;//(setting_num > 7'd59) ? 59 : setting_num;
                end
                if(setting_mode == 2'b10 & has_setted == 0)begin
                    blink_r <= 8'b00110000;
                    max_M <= setting_num % 60;//(setting_num > 7'd59) ? 59 : setting_num;
                end
                if(setting_mode == 2'b11 && has_setted == 0)begin
                    blink_r <= 8'b11000000;
                    max_H <= setting_num % 24;//(setting_num > 7'd23) ? 23 : setting_num;
                end
                if(setting_mode == 2'b00 && has_setted == 0)begin
                    blink_r <= 8'b11111111;
                end
            end
        end
        if(is_running == 1)begin
            blink_r <= 8'b00000000;
            if(enable == 1)begin
                if(setting_mode != 2'b00 && has_setted == 0)begin
                    is_running <= 0;
                end
                if(setting_mode != 2'b00 && has_setted == 1)begin
                    is_running <= 1;
                end
                if(setting_mode == 0)begin
                    has_setted <= 0;
                end
            end
            if(max_H == rH && max_M == rM && max_S == rS && rTMS == 99)begin
                rTMS <= 99;
                if(counter == 199999999)begin
                    counter <= 0;
                end else begin
                    counter <= counter + 1;
                end
                if(is_stop == 0)begin
                    alram_LED <= (counter / 100000000) % 2;
                end
                else begin
                    alram_LED <= 0;
                end
                if(enable == 1)begin
                    if(reset == 1 && is_rst_pushdown == 0)begin
                        counter <= 0;
                        rTMS <= 99;
                        rS <= 0;
                        rM <= 0;
                        rH <= 0;
                        is_rst_pushdown <= 1;
                        is_stop <= 1;
                    end
                    if(reset == 0)begin
                        is_rst_pushdown <= 0;
                    end
                end
            end else begin
                alram_LED <= 0;
                if(enable == 1)begin
                    if(start_stop == 1 && is_stop_pushdown == 0)begin
                        is_stop = ~is_stop;
                        is_stop_pushdown <= 1;
                    end
                    if(start_stop == 0)begin
                        is_stop_pushdown <= 0;
                    end
                    if(reset == 1 && is_rst_pushdown == 0)begin
                        counter <= 0;
                        rTMS <= 99;
                        rS <= 0;
                        rM <= 0;
                        rH <= 0;
                        is_rst_pushdown <= 1;
                    end
                    if(reset == 0)begin
                        is_rst_pushdown <= 0;
                    end
                end
                if(is_stop == 0)begin
                    counter <= counter + 1;//1s = 100000000
                    if(counter == 999999)begin
                        counter <= 0;
                        if(rTMS == 99)begin
                            if(rS == 59)begin
                                if(rM == 59)begin
                                    rH = (rH + 1) % 24;
                                end
                                rM = (rM + 1) % 60;
                            end
                            rS = (rS + 1) % 60;
                        end
                        rTMS <= (rTMS + 1) % 100;
                    end else begin
                        counter <= counter + 1;
                    end
                end
            end
        end
    end
endmodule

module DigitalTimer (
    input clk,//���ӵ�ʱ�Ӷ˿� CLK100MHZ������ E3
    input RST,//��λ��ť��������Ч
    input StartOrPause,//��ʱ����ʼ����ͣ������ 1 �ο�ʼ���ٰ� 1 ����ͣ
    input ReadPara,//��ȡ���������������ý����󣬵��� 1 �Σ���ȡ����
    input TimeFormat,//=0 ��ʾ 24 Сʱ�ƣ�=1 ��ʾ 12 Сʱ��
    input [1:0] mode,//����ѡ��00 ����ʱ�ӣ�01 ����ʱ��10 ��ʱ����11 ��������
    input [1:0] ParaSelect,// �������ã�00 �ޣ�01 ����������10 ���÷��ӣ�11 ����Сʱ
    input [1:0] AlarmNo,// ������ţ�0~3
    input [3:0] data_h,//���ò�����λ��ʹ�� BCD ���ʾ
    input [3:0] data_l,//���ò�����λ��ʹ�� BCD ���ʾ
    output Afternoon,//12 Сʱ��ʱ������ʱ�����Ϊ 1
    output [2:0] TimeKeeper,//������� 3 ɫָʾ��
    output [2:0] AlarmDisplay,//������� 3 ɫָʾ��
    output [7:0] segs,//�߶����������ֵ����ʾ����
    output [7:0] an//�߶�����ܿ���λ������ʱ���֡���
);
// Add your code
    wire [6:0] display_BUS_time_H [0:3];
    wire [6:0] display_BUS_time_M [0:3];
    wire [6:0] display_BUS_time_S [0:3]; 
    wire [6:0] display_BUS_time_tMS [0:3];
    wire [7:0]blink_BUS [0:3];
    wire [6:0]data_BUS;
    wire enable [0:3];
    assign enable[0] = (mode == 2'b00) ? 1 : 0;
    assign enable[1] = (mode == 2'b01) ? 1 : 0;
    assign enable[2] = (mode == 2'b10) ? 1 : 0;
    assign enable[3] = (mode == 2'b11) ? 1 : 0;
    BCD2INT BCD2INT0(
        .data_h(data_h),
        .data_l(data_l),
        .data_out(data_BUS)
    );

    clock clock0( 
        .clk(clk),
        .setting_num(data_BUS),
        .set(ReadPara),
        .setting_mode(ParaSelect),
        .enable(enable[0]),
        .H(display_BUS_time_H[0]),
        .M(display_BUS_time_M[0]),
        .S(display_BUS_time_S[0]),
        .tms(display_BUS_time_tMS[0]),
        .blink_chose(blink_BUS[0]),
        .TimeKeeper(TimeKeeper)
    );
    alarm alarm0(
        .clk(clk),
        .now_H(display_BUS_time_H[0]),
        .now_M(display_BUS_time_M[0]),
        .now_S(display_BUS_time_S[0]),
        .setting_num(data_BUS),
        .enable(enable[3]),
        .AlarmNo(AlarmNo),
        .set(ReadPara),
        .setting_mode(ParaSelect),
        .setted_H(display_BUS_time_H[3]),
        .setted_M(display_BUS_time_M[3]),
        .setted_S(display_BUS_time_S[3]),
        .blink_chose(blink_BUS[3]),
        .AlarmDisplay(AlarmDisplay)
    );
    stopwatch stopwatch0(
        .srart_stop(StartOrPause),
        .reset(RST),
        .enable(enable[2]),
        .clk(clk),
        .H(display_BUS_time_H[2]),
        .M(display_BUS_time_M[2]),
        .S(display_BUS_time_S[2]),
        .tms(display_BUS_time_tMS[2]),
        .blink_chose(blink_BUS[2])
    );
    timers timer0(
        .clk(clk),
        .setting_mode(ParaSelect),
        .setting_num(data_BUS),
        .start_stop(StartOrPause),
        .enable(enable[1]),
        .reset(RST),
        .set(ReadPara),
        .blink_chose(blink_BUS[1]),
        .H(display_BUS_time_H[1]),
        .M(display_BUS_time_M[1]),
        .S(display_BUS_time_S[1]),
        .tms(display_BUS_time_tMS[1]),
        .red_LED(AlarmDisplay[1])
    );

    wire [3:0]trans2blinker_0;
    wire [3:0]trans2blinker_1; 
    wire [3:0]trans2blinker_2; 
    wire [3:0]trans2blinker_3; 
    wire [3:0]trans2blinker_4;
    wire [3:0]trans2blinker_5;
    wire [3:0]trans2blinker_6;
    wire [3:0]trans2blinker_7;
    wire [7:0]trans2display_point;
    trans_1224 trans_1224_0(
        .is_12(TimeFormat),
        .H(display_BUS_time_H[mode]),
        .M(display_BUS_time_M[mode]),
        .S(display_BUS_time_S[mode]),
        .ms(display_BUS_time_tMS[mode]),
        .afternoon_led(Afternoon),
        .DATA0(trans2blinker_0),
        .DATA1(trans2blinker_1),
        .DATA2(trans2blinker_2),
        .DATA3(trans2blinker_3),
        .DATA4(trans2blinker_4),
        .DATA5(trans2blinker_5),
        .DATA6(trans2blinker_6),
        .DATA7(trans2blinker_7),
        .points(trans2display_point)
    );
    wire [3:0]blinker2display_0;
    wire [3:0]blinker2display_1; 
    wire [3:0]blinker2display_2;
    wire [3:0]blinker2display_3; 
    wire [3:0]blinker2display_4;
    wire [3:0]blinker2display_5;
    wire [3:0]blinker2display_6;
    wire [3:0]blinker2display_7;
    blinker blinker0(
        .clk(clk),
        .blinker_addr(blink_BUS[mode]),
        .DATA0(trans2blinker_0),
        .DATA1(trans2blinker_1),
        .DATA2(trans2blinker_2),
        .DATA3(trans2blinker_3),
        .DATA4(trans2blinker_4),
        .DATA5(trans2blinker_5),
        .DATA6(trans2blinker_6),
        .DATA7(trans2blinker_7),
        .OUT_DATA0(blinker2display_0),
        .OUT_DATA1(blinker2display_1),
        .OUT_DATA2(blinker2display_2),
        .OUT_DATA3(blinker2display_3),
        .OUT_DATA4(blinker2display_4),
        .OUT_DATA5(blinker2display_5),
        .OUT_DATA6(blinker2display_6),
        .OUT_DATA7(blinker2display_7)
    );
    display display0(
        .clk(clk),
        .DATA0(blinker2display_0),
        .DATA1(blinker2display_1),
        .DATA2(blinker2display_2),
        .DATA3(blinker2display_3),
        .DATA4(blinker2display_4),
        .DATA5(blinker2display_5),
        .DATA6(blinker2display_6),
        .DATA7(blinker2display_7),
        .points(trans2display_point),
        .SEG(segs),
        .choseLED(an)
        );

endmodule


```

其中译码器和分配器使用的是与上一个实验完全相同的模块，故不再赘述。

### 仿真

由于功能过于复杂，不进行仿真而直接烧录FPGA进行验证。

### 验证

使用框架提供的约束文件：

```verilog
set_property -dict { PACKAGE_PIN E3    IOSTANDARD LVCMOS33 } [get_ports { clk }]; #IO_L12P_T1_MRCC_35 Sch=clk100mhz
```

使用vivado对代码进行综合并生成比特流，烧录进开发板：

![image-20240312212658399](/home/cx_li/.var/app/io.typora.Typora/config/Typora/typora-user-images/image-20240312212658399.png)

烧入开发板后时钟如此工作：



可见开发板可以按照预期工作。

秒表：![5e31f0b6a3194d4d577383c257a948f3](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/03/5e31f0b6a3194d4d577383c257a948f3.jpg)

![9c6ce8190202c8616b9eb5979357ff9e](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/03/9c6ce8190202c8616b9eb5979357ff9e.jpg)

倒计时结束闪烁绿灯：![52e963c7bf1fed9674983257534ce926](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/03/52e963c7bf1fed9674983257534ce926.jpg)

闹钟设置（没有亮的位置正在闪烁，表示正在设置的位置）：![274cf691af98123fdc0cf9b9131ebef9](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/03/274cf691af98123fdc0cf9b9131ebef9.jpg)

12小时制：![693ff60fb8e60997a8a91c94daa6f049](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/03/693ff60fb8e60997a8a91c94daa6f049.jpg)

完成设置，等待按下set后开始运行：![b1ad3c8dc49f3d1c4ae99ed80db09fe9](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/03/b1ad3c8dc49f3d1c4ae99ed80db09fe9.jpg)

闹钟闪烁![b9613e63f2f7148f928b76e2588fc259](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/03/b9613e63f2f7148f928b76e2588fc259.jpg)

整点闪烁：![c21d35a70b24b07ef15ed2438f92470f](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/03/c21d35a70b24b07ef15ed2438f92470f.jpg)

### 错误现象及分析

实验中没有遇到错误。

---

## 思考题

### 1.分析 32 个 32 位的寄存器堆占用的逻辑片资源

分析如下：![image-20240312224013112](/home/cx_li/.var/app/io.typora.Typora/config/Typora/typora-user-images/image-20240312224013112.png)

该寄存器占用资源很少，只有不超过0.5%的逻辑片资源站占用。

### 2. 分析 64 位移位寄存器的时序性能和资源占用情况；并通过资料查找到其他的生成 LFSR 的反馈公式

时序性能分析如下：

![截图 2024-03-17 20-15-49](/home/cx_li/图片/截图/截图 2024-03-17 20-15-49.png)

没有出现时序问题。

资源占用情况如下：

![image-20240317201915544](/home/cx_li/.var/app/io.typora.Typora/config/Typora/typora-user-images/image-20240317201915544.png)

可见占用较少。

k位LFSR的反馈公式为：
$$
new\ x_i = \left \{
\begin{aligned}
&\left (\sum_{i=0}^{k-1}a_ix_i\right )\mod 2,(\forall i\in [0,k-1]\cap N, a_i\in \{0,1\}), &i = k-1\\
& x_{i+1},& i \not= k-1
\end{aligned}
\right .
$$
此处模2加法等价与异或。

### 3. 数字时钟中是如何实现倒计时和毫秒计时器功能？

毫秒级计时器中有两个寄存器分别记录毫秒数和时钟数，当时钟数寄存器等于（时钟赫兹数*赫兹/1000 - 1）时下一个周期时钟数寄存器归零而毫秒数寄存器加一。从而实现了毫秒级的计时功能。

倒计时中，维护一个上述实现的按照毫秒数寄存器，然后显示的数字是目标时长的毫秒数减去毫秒数寄存器的值，通过差值是否为0判断是否到时间，从而可以实现倒计时。

### 4. 如何实现寄存器堆中 0 号寄存器的值始终为零？

在verilog中进行判断：判断写选择是否是0号，是的话就写入0否则写入写总线上的值即可实现寄存器堆中 0 号寄存器的值始终为零。
