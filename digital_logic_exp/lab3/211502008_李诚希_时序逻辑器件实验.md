# 数字逻辑与计算机组成实验 第三次实验 算术逻辑部件实验 实验报告

> 211502008 李诚希
>
> chengxili@smail.nju.edu.cn

## 1. 带标志位的加减运算部件

### 整体设计

如下图，使用加法器和和一二路选择器和非门阵列实现带标志位的可以加法和减法的运算部件。其中的加法器使用四位先行进位串联成32位实现。

![image-20240323213631569](C:\Users\13041\AppData\Roaming\Typora\typora-user-images\image-20240323213631569.png)

### 模块设计

模块设计如下:

- **Adder32**:主模块，它接收两个32位的输入`x`和`y`，以及一个控制信号`sub`。如果`sub`为0，执行加法；如果为1，执行减法,即取反输入并将cin设置为1。它使用两个CLA_16模块来计算结果，并生成溢出（OF）、符号（SF）、零（ZF）和进位（CF）标志。

  ```verilog
  module Adder32(
        output [31:0] f,
        output OF, SF, ZF, CF,
        output cout,
        input [31:0] x, y,
        input sub
  	);
        wire [31:0] y_in = (sub == 0) ? y : ~y;
        wire cin, c_a2bm;
        assign cin = sub;
        CLA_16 CLA_16_0(
              .f(f[15:0]),
              .cout(c_a2b),
              .x(x[15:0]),
              .y(y_in[15:0]),
              .cin(cin)
        );
        CLA_16 CLA_16_1(
              .f(f[31:16]),
              .cout(cout),
              .x(x[31:16]),
              .y(y_in[31:16]),
              .cin(c_a2b)
        );
        assign OF = (~x[31] & ~y_in[31] & f[31]) | (x[31] & y_in[31] & ~f[31]);
        assign SF = f[31];
        assign CF = cin ^ cout;
        assign ZF = (f == 31'b0000000000000000) ? 1 : 0;
  endmodule
  ```

- **CLA_16**: 这是一个16位进位查找加法器（Carry-Lookahead Adder）模块，它用于加速加法操作中进位的计算。它接收两个16位的输入和一个进位输入（cin），并输出16位的结果和一个进位输出（cout）。

  ```verilog
  module CLA_16(
         output wire [15:0] f,
         output wire  cout, 
         input [15:0] x, y,
         input cin
    );
   //add your code here
        wire [3:0] Pi,Gi;
        wire [4:0] c;
        assign c[0] = cin;
        CLA_group cla0(f[3:0],Pi[0],Gi[0],x[3:0],y[3:0],c[0]);
        CLA_group cla1(f[7:4],Pi[1],Gi[1],x[7:4],y[7:4],c[1]);
        CLA_group cla2(f[11:8],Pi[2],Gi[2],x[11:8],y[11:8],c[2]);
        CLA_group cla3(f[15:12],Pi[3],Gi[3],x[15:12],y[15:12],c[3]);
        CLU clu(c[4:1],Pi,Gi, c[0]);
        assign cout = c[4];
  endmodule
  ```

- **CLA_group**: 这是一个4位进位查找组（Carry-Lookahead Group）模块，它是CLA_16模块的一部分。它接收4位的输入和一个进位输入，计算4位的结果，并生成组进位（pg）和组生成（gg）信号，这些信号用于进位的快速计算。

  ```verilog
  module CLA_group (
       output [3:0] f,
       output pg,gg,
       input [3:0] x, y,
        input cin
  );
        wire [4:0] c;
        wire [4:1] p, g;
        assign c[0] = cin;
        FA_PG fa0(f[0], p[1], g[1],x[0], y[0], c[0]);
        FA_PG fa1(f[1], p[2], g[2],x[1], y[1], c[1]);
        FA_PG fa2(f[2], p[3], g[3],x[2], y[2], c[2]);
        FA_PG fa3(f[3], p[4], g[4],x[3], y[3], c[3]);
        CLU clu(c[4:1],p, g, c[0]);
        assign pg=p[1] & p[2] & p[3] & p[4];
        assign gg= g[4] | (p[4] & g[3]) | (p[4] & p[3] & g[2]) | (p[4] & p[3] & p[2] & g[1]);
  endmodule
  ```

- **CLU**: 这是一个进位逻辑单元（Carry Logic Unit）模块，它根据进位生成（g）和进位传播（p）信号计算进位输出。

  ```verilog
  module CLU (
        output [4:1] c,
        input [4:1] p, g,
        input c0
  );
        assign c[1] = g[1] | (p[1] & c0);
        assign c[2] = g[2] | (p[2] & g[1]) | (p[2] & p[1] & c0);
        assign c[3] = g[3] | (p[3] & g[2]) | (&{p[3:2], g[1]}) | (&{p[3:1], c0});
        assign c[4] = g[4] | (p[4] & g[3]) | (&{p[4:3], g[2]}) | (&{p[4:2], g[1]}) | (&{p[4:1], c0});
  endmodule
  ```

- **FA_PG**: 这是一个全加器（Full Adder）模块，它接收两个1位输入和一个进位输入，计算1位的结果，并生成进位传播（p）和进位生成（g）信号。

  ```verilog
  module FA_PG (
        output f, p, g,
        input x, y, cin
  );
        assign f = x ^ y ^ cin;
        assign p = x | y;
        assign g = x & y;
  endmodule
  ```

### 仿真

仿真脚本直接给`Adder32`输入随机信号尝试不同的输入的输出与程序的计算结果是否相同：

```verilog
`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 2023/09/17 22:02:27
// Design Name: 
// Module Name: Adder32_tb
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module Adder32_tb(    );
  parameter N = 32;      // Operand widths
  reg [N-1:0] A, B;
  reg CIN;
  wire [N-1:0] S;
  wire COUT;
  wire OF,SF,ZF,CF;
  integer i, errors;
  reg xpectCF,xpectOF;
  reg [N-1:0] xpectS;
  
   Adder32 adder_inst(.f(S),.OF(OF),.SF(SF),.ZF(ZF),.CF(CF),.cout(COUT),.x(A),.y(B),.sub(CIN));
  task checkadd;
    begin
      //$display("%d,%d,%d,%d,%d,%d,%d,%d", CIN, A, B, S, OF, SF, ZF, CF);
       {xpectCF,xpectS} = (CIN ? (A-B):(A+B));         
      if ( (xpectCF!==CF) || (xpectS!==S) ) begin
        errors = errors + 1;
        $display("ERROR: CIN,A,B = %1b,%8h,%8h, CF,S = %1b,%8h, should be %1b,%8h, OF,SF,ZF,COUT=%1b, %1b, %1b, %1b." ,
                 CIN, A, B, CF, S, xpectCF, xpectS ,OF,SF,ZF,COUT);
      end
      if ((B==A) && (CIN==1)&&(ZF==0 )) begin
        errors = errors + 1;
        $display("ERROR: CIN,A,B = %1b,%8h,%8h, CF,S = %1b,%8h, should be %1b,%8h, OF,SF,ZF,COUT=%1b, %1b, %1b, %1b." ,
                 CIN, A, B, CF, S, xpectCF, xpectS ,OF,SF,ZF,COUT);
      end
      if(CIN) xpectOF=(~B[N-1]&A[N-1]&~S[N-1]) |(~A[N-1]&B[N-1]&S[N-1]); 
       else   xpectOF=(B[N-1]&A[N-1]&~S[N-1]) |(~A[N-1]&~B[N-1]&S[N-1]);
      if (xpectOF!=OF) begin
        errors = errors + 1;
        $display("ERROR: CIN,A,B = %1b,%8h,%8h, CF,S = %1b,%8h, should be %1b,%8h, OF,SF,ZF,COUT=%1b, %1b, %1b, %1b." ,
                 CIN, A, B, CF, S, xpectCF, xpectS ,OF,SF,ZF,COUT);
      end
    end
  endtask
  integer SEED;
  initial begin
    SEED = $time;
    $dumpfile("Adder32_tb.vcd");
    $dumpvars(0, Adder32_tb);
    errors = 0;
    A = $random(SEED);                           
   for (i=0; i<10000; i=i+1) begin          
          B = ~A; CIN = 0;  #10 ; checkadd;  
          B = ~A; CIN = 1;  #10 ; checkadd;     
          B = A;  CIN = 1;  #10 ; checkadd;    
          A = $random; B= $random;                          
          CIN = 0; #10 ; checkadd;     
          CIN = 1; #10 ; checkadd;        
    end
    $display("Adder32 test done. Errors: %0d .", errors);
    $stop(1);
  end

endmodule

```

为了方便使用iverilog编译和仿真我编写了如下Makefile:

```makefile
.PHONY : simulate_regfile32, simulate_encryption6b simulate clean

FILES = $(wildcard $(project_name)*.v)
vvp_files = $(wildcard *.vvp)
vcd_files = $(wildcard *.vcd)
sim_file = $(wildcard *_sim)

simulate:
	iverilog $(FILES) -o $(project_name)_sim.vvp
	vvp -n $(project_name)_sim.vvp -lxt2

clean:
	rm $(vvp_files) $(vcd_files) $(sim_file)
```

接着使用如下指令进行编译和仿真得到波形文件：

```bash
make simulate project_name=reg
```

使用GTKWave打开仿真生成的波形文件`regfile32_tb.vcd`：

![image-20240312143018667](/home/cx_li/.var/app/io.typora.Typora/config/Typora/typora-user-images/image-20240312143018667.png)

仿真结果表明该电路只写使能为1才会给rw对应位置写入，且只要有ra和rb，就可以正确读取响应位置的数据。

### 验证

使用实验框架提供额约束文件：

```verilog
set_property CLOCK_DEDICATED_ROUTE FALSE [get_nets clk_IBUF ];
set_property -dict { PACKAGE_PIN J15   IOSTANDARD LVCMOS33 } [get_ports { busw[0] }]; #IO_L24N_T3_RS0_15 Sch=sw[0]
set_property -dict { PACKAGE_PIN L16   IOSTANDARD LVCMOS33 } [get_ports { busw[1] }]; #IO_L3N_T0_DQS_EMCCLK_14 Sch=sw[1]
set_property -dict { PACKAGE_PIN M13   IOSTANDARD LVCMOS33 } [get_ports { busw[2] }]; #IO_L6N_T0_D08_VREF_14 Sch=sw[2]
set_property -dict { PACKAGE_PIN R15   IOSTANDARD LVCMOS33 } [get_ports { busw[3] }]; #IO_L13N_T2_MRCC_14 Sch=sw[3]
set_property -dict { PACKAGE_PIN R17   IOSTANDARD LVCMOS33 } [get_ports { ra[0] }]; #IO_L12N_T1_MRCC_14 Sch=sw[4]
set_property -dict { PACKAGE_PIN T18   IOSTANDARD LVCMOS33 } [get_ports { ra[1] }]; #IO_L7N_T1_D10_14 Sch=sw[5]
set_property -dict { PACKAGE_PIN U18   IOSTANDARD LVCMOS33 } [get_ports { ra[2] }]; #IO_L17N_T2_A13_D29_14 Sch=sw[6]
set_property -dict { PACKAGE_PIN R13   IOSTANDARD LVCMOS33 } [get_ports { rb[0] }]; #IO_L5N_T0_D07_14 Sch=sw[7]
set_property -dict { PACKAGE_PIN T8    IOSTANDARD LVCMOS33 } [get_ports { rb[1] }]; #IO_L24N_T3_34 Sch=sw[8]
set_property -dict { PACKAGE_PIN U8    IOSTANDARD LVCMOS33 } [get_ports { rb[2] }]; #IO_25_34 Sch=sw[9]
set_property -dict { PACKAGE_PIN R16   IOSTANDARD LVCMOS33 } [get_ports { rw[0] }]; #IO_L15P_T2_DQS_RDWR_B_14 Sch=sw[10]
set_property -dict { PACKAGE_PIN T13   IOSTANDARD LVCMOS33 } [get_ports { rw[1] }]; #IO_L23P_T3_A03_D19_14 Sch=sw[11]
set_property -dict { PACKAGE_PIN H6    IOSTANDARD LVCMOS33 } [get_ports { rw[2] }]; #IO_L24P_T3_35 Sch=sw[12]
set_property -dict { PACKAGE_PIN U12   IOSTANDARD LVCMOS33 } [get_ports { rd_hi[0] }]; #IO_L20P_T3_A08_D24_14 Sch=sw[13]
set_property -dict { PACKAGE_PIN U11   IOSTANDARD LVCMOS33 } [get_ports { rd_hi[1] }]; #IO_L19N_T3_A09_D25_VREF_14 Sch=sw[14]
set_property -dict { PACKAGE_PIN V10   IOSTANDARD LVCMOS33 } [get_ports { we }]; #IO_L21P_T3_DQS_14 Sch=sw[15]
set_property -dict { PACKAGE_PIN H17   IOSTANDARD LVCMOS33 } [get_ports { busa8[0] }]; #IO_L18P_T2_A24_15 Sch=led[0]
set_property -dict { PACKAGE_PIN K15   IOSTANDARD LVCMOS33 } [get_ports { busa8[1] }]; #IO_L24P_T3_RS1_15 Sch=led[1]
set_property -dict { PACKAGE_PIN J13   IOSTANDARD LVCMOS33 } [get_ports { busa8[2] }]; #IO_L17N_T2_A25_15 Sch=led[2]
set_property -dict { PACKAGE_PIN N14   IOSTANDARD LVCMOS33 } [get_ports { busa8[3] }]; #IO_L8P_T1_D11_14 Sch=led[3]
set_property -dict { PACKAGE_PIN R18   IOSTANDARD LVCMOS33 } [get_ports { busa8[4] }]; #IO_L7P_T1_D09_14 Sch=led[4]
set_property -dict { PACKAGE_PIN V17   IOSTANDARD LVCMOS33 } [get_ports { busa8[5] }]; #IO_L18N_T2_A11_D27_14 Sch=led[5]
set_property -dict { PACKAGE_PIN U17   IOSTANDARD LVCMOS33 } [get_ports { busa8[6] }]; #IO_L17P_T2_A14_D30_14 Sch=led[6]
set_property -dict { PACKAGE_PIN U16   IOSTANDARD LVCMOS33 } [get_ports { busa8[7] }]; #IO_L18P_T2_A12_D28_14 Sch=led[7]
set_property -dict { PACKAGE_PIN V16   IOSTANDARD LVCMOS33 } [get_ports { busb8[0] }]; #IO_L16N_T2_A15_D31_14 Sch=led[8]
set_property -dict { PACKAGE_PIN T15   IOSTANDARD LVCMOS33 } [get_ports { busb8[1] }]; #IO_L14N_T2_SRCC_14 Sch=led[9]
set_property -dict { PACKAGE_PIN U14   IOSTANDARD LVCMOS33 } [get_ports { busb8[2] }]; #IO_L22P_T3_A05_D21_14 Sch=led[10]
set_property -dict { PACKAGE_PIN T16   IOSTANDARD LVCMOS33 } [get_ports { busb8[3] }]; #IO_L15N_T2_DQS_DOUT_CSO_B_14 Sch=led[11]
set_property -dict { PACKAGE_PIN V15   IOSTANDARD LVCMOS33 } [get_ports { busb8[4] }]; #IO_L16P_T2_CSI_B_14 Sch=led[12]
set_property -dict { PACKAGE_PIN V14   IOSTANDARD LVCMOS33 } [get_ports { busb8[5] }]; #IO_L22N_T3_A04_D20_14 Sch=led[13]
set_property -dict { PACKAGE_PIN V12   IOSTANDARD LVCMOS33 } [get_ports { busb8[6] }]; #IO_L20N_T3_A07_D23_14 Sch=led[14]
set_property -dict { PACKAGE_PIN V11   IOSTANDARD LVCMOS33 } [get_ports { busb8[7] }]; #IO_L21N_T3_DQS_A06_D22_14 Sch=led[15]
```

使用vivado对代码进行综合并生成比特流，烧录进开发板：

![image-20240312143759580](/home/cx_li/.var/app/io.typora.Typora/config/Typora/typora-user-images/image-20240312143759580.png)

烧录之后在开发板上进行实验：

![537cb875077c391ce6e09be032866c0b](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/537cb875077c391ce6e09be032866c0b.jpg)

![7948864d16d7bd3eae9bc5942a26a278](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/7948864d16d7bd3eae9bc5942a26a278.jpg)

![da24f63ee069de3b4de184d1af05e90e](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/da24f63ee069de3b4de184d1af05e90e.jpg)

可见只有被选择通路才能在时钟下降沿写入，其他情况均不会写入。

### 错误现象及分析

实验中没有遇到错误。

## 2. 桶形移位器

### 整体设计

使用多路选择器级联实现一个周期内完成移位。

### 模块设计

LFSR使用反馈方程x64=x4⊕x3⊕x1⊕x0，在点击按钮时会重置寄存器中的内容并将seed放入寄存器，然后每个按钮按下周期将所有寄存器移动一位，空出来的位置放入使用反馈方程生成的比特。代码如下：

```verilog

module lfsr(              //64位线性移位寄存器
	output reg [63:0] dout,
    input  [63:0]  seed,
	input  clk,
	input  load
	);
    reg new_bit = 0;
    reg has_loaded = 0;
    always @(posedge clk) begin
        if(load == 1)begin
            dout <= seed;
            has_loaded <= 1;
        end
        else if(has_loaded == 1)begin
            new_bit <= dout[0] ^ dout[1] ^ dout[2] ^ dout[3];
            /*
            ```python3
            for i in range(0, 63):
                print("dout[{}] <= dout[{}];".format(str(i), str(i+1)))
```
            */
            dout[0] <= dout[1];
            dout[1] <= dout[2];
            dout[2] <= dout[3];
            dout[3] <= dout[4];
            dout[4] <= dout[5];
            dout[5] <= dout[6];
            dout[6] <= dout[7];
            dout[7] <= dout[8];
            dout[8] <= dout[9];
            dout[9] <= dout[10];
            dout[10] <= dout[11];
            dout[11] <= dout[12];
            dout[12] <= dout[13];
            dout[13] <= dout[14];
            dout[14] <= dout[15];
            dout[15] <= dout[16];
            dout[16] <= dout[17];
            dout[17] <= dout[18];
            dout[18] <= dout[19];
            dout[19] <= dout[20];
            dout[20] <= dout[21];
            dout[21] <= dout[22];
            dout[22] <= dout[23];
            dout[23] <= dout[24];
            dout[24] <= dout[25];
            dout[25] <= dout[26];
            dout[26] <= dout[27];
            dout[27] <= dout[28];
            dout[28] <= dout[29];
            dout[29] <= dout[30];
            dout[30] <= dout[31];
            dout[31] <= dout[32];
            dout[32] <= dout[33];
            dout[33] <= dout[34];
            dout[34] <= dout[35];
            dout[35] <= dout[36];
            dout[36] <= dout[37];
            dout[37] <= dout[38];
            dout[38] <= dout[39];
            dout[39] <= dout[40];
            dout[40] <= dout[41];
            dout[41] <= dout[42];
            dout[42] <= dout[43];
            dout[43] <= dout[44];
            dout[44] <= dout[45];
            dout[45] <= dout[46];
            dout[46] <= dout[47];
            dout[47] <= dout[48];
            dout[48] <= dout[49];
            dout[49] <= dout[50];
            dout[50] <= dout[51];
            dout[51] <= dout[52];
            dout[52] <= dout[53];
            dout[53] <= dout[54];
            dout[54] <= dout[55];
            dout[55] <= dout[56];
            dout[56] <= dout[57];
            dout[57] <= dout[58];
            dout[58] <= dout[59];
            dout[59] <= dout[60];
            dout[60] <= dout[61];
            dout[61] <= dout[62];
            dout[62] <= dout[63];
            dout[63] <= new_bit;
        end else begin
            dout <= 0;
        end
    end
endmodule
```

然后再在加密模块中调用这个LFSR，每次读取其输出并与信息异或即可。代码如下：

```verilog
module encryption6b(
    output [7:0] dataout,    //输出加密或解密后的8比特ASCII数据。
    output reg ready,       //输出有效标识，高电平说明输出有效，第6周期高电平
    output [5:0] key,       //输出6位加密码
    input clk,             // 时钟信号，上升沿有效
    input load,            //载入seed指示，高电平有效
    input [7:0] datain       //输入数据的8比特ASCII码。
);
    wire  [63:0] seed=64'ha845fd7183ad75c4;       //初始64比特seed=64'ha845fd7183ad75c4
//add your code here
    reg [7:0]datain_R = 0;
    wire [63:0]lfsr_out;
    reg [2:0] counter = 3'b000;
    lfsr L(
        .dout(lfsr_out),
        .seed(seed),
        .clk(clk),
        .load(load)
    );
    assign key = lfsr_out[63:58];
    assign dataout[7] = datain_R[7]; 
    assign dataout[6] = datain_R[6]; 
    assign dataout[5] = datain_R[5] ^ lfsr_out[63]; 
    assign dataout[4] = datain_R[4] ^ lfsr_out[62]; 
    assign dataout[3] = datain_R[3] ^ lfsr_out[61]; 
    assign dataout[2] = datain_R[2] ^ lfsr_out[60]; 
    assign dataout[1] = datain_R[1] ^ lfsr_out[59]; 
    assign dataout[0] = datain_R[0] ^ lfsr_out[58]; 
    always @(posedge clk) begin
        if(load == 1)begin
            datain_R <= datain;
            counter <= 6'b000;
            ready <= 1'b0;
        end else begin
            if(counter == 3'b101)begin
                counter <= 3'b000;
                ready <= 1'b1;
            end else begin
                counter <= counter + 1;
                ready <= 1'b0;
            end
        end
    end
endmodule
```

### 仿真

仿真脚本先关闭load运行几个时钟，然后打开load运行两个时钟再关闭load，然后又运行若干个时钟：

```verilog
`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 2023/09/17 16:34:51
// Design Name: 
// Module Name: encryption6b_tb
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module encryption6b_tb(    );
// add your code

    wire [7:0] dataout;
    wire ready_w;
    wire [5:0] key_w;
    reg [5:0] key;
    assign key_w = key;
    wire clk_w;
    reg clk;
    assign clk_w = clk;
    wire load_w;
    reg load;
    assign load_w = load;
    wire [7:0] datain_w;
    reg [7:0] datain;
    assign datain_w = datain;

    encryption6b encryption6b_test(
        .dataout(dataout),
        .ready(ready_w),
        .key(key_w),
        .clk(clk_w),
        .load(load_w),
        .datain(datain_w)
    );
    integer i;
    initial begin
        $dumpfile("encryption6b_tb.vcd");
        $dumpvars(0, encryption6b_tb);
        clk = 0;
        load = 0;
        datain = 8'b10101010;
        key = 8'b10010100;
        for(i = 0; i < 40; i = i + 1)begin
            clk = ~clk;
            #2;
        end
        clk = 0;
        load = 1;
        #2;
        clk = 1;
        #2;
        clk = 0;
        #2;
        clk = 1;
        #2;
        clk = 0;
        #2;
        load = 0;
        #2;
        for(i = 0; i < 40; i = i + 1)begin
            clk = ~clk;
            #2;
        end
    end
endmodule

```

使用上述makefile脚本和如下指令调用iverilog进编译和行仿真得到波形文件：

```bash
make simulate project_name=reg
```

使用GTKWave打开仿真生成的波形文件`encryption6b_tb.vcd`（此时输入为10101010）：

![image-20240312163320726](/home/cx_li/.var/app/io.typora.Typora/config/Typora/typora-user-images/image-20240312163320726.png)

可以看到仿真结果符合预期，即没有load过且load为0时始终不变，load为1且时钟上升时写入，此后load为0时随着时钟运行。

下图为使用仿真第一次ready时的输出信号（10110100）作为输入得到的仿真：

![image-20240312163612631](/home/cx_li/.var/app/io.typora.Typora/config/Typora/typora-user-images/image-20240312163612631.png)

可见同一段内容可以被加密然后解密回复相同的比特串（10101010）。

仿真结果符合预期。

### 验证

使用实验框架提供的约束代码：
``` verilog
set_property CLOCK_DEDICATED_ROUTE FALSE [get_nets clk_IBUF ];
set_property -dict { PACKAGE_PIN J15   IOSTANDARD LVCMOS33 } [get_ports { datain[0] }]; #IO_L24N_T3_RS0_15 Sch=sw[0]
set_property -dict { PACKAGE_PIN L16   IOSTANDARD LVCMOS33 } [get_ports { datain[1] }]; #IO_L3N_T0_DQS_EMCCLK_14 Sch=sw[1]
set_property -dict { PACKAGE_PIN M13   IOSTANDARD LVCMOS33 } [get_ports { datain[2] }]; #IO_L6N_T0_D08_VREF_14 Sch=sw[2]
set_property -dict { PACKAGE_PIN R15   IOSTANDARD LVCMOS33 } [get_ports { datain[3] }]; #IO_L13N_T2_MRCC_14 Sch=sw[3]
set_property -dict { PACKAGE_PIN R17   IOSTANDARD LVCMOS33 } [get_ports { datain[4] }]; #IO_L12N_T1_MRCC_14 Sch=sw[4]
set_property -dict { PACKAGE_PIN T18   IOSTANDARD LVCMOS33 } [get_ports { datain[5] }]; #IO_L7N_T1_D10_14 Sch=sw[5]
set_property -dict { PACKAGE_PIN U18   IOSTANDARD LVCMOS33 } [get_ports { datain[6] }]; #IO_L17N_T2_A13_D29_14 Sch=sw[6]
set_property -dict { PACKAGE_PIN R13   IOSTANDARD LVCMOS33 } [get_ports { datain[7] }]; #IO_L5N_T0_D07_14 Sch=sw[7]
set_property -dict { PACKAGE_PIN V10   IOSTANDARD LVCMOS33 } [get_ports { load }]; #IO_L21P_T3_DQS_14 Sch=sw[15]
set_property -dict { PACKAGE_PIN H17   IOSTANDARD LVCMOS33 } [get_ports { dataout[0] }]; #IO_L18P_T2_A24_15 Sch=led[0]
set_property -dict { PACKAGE_PIN K15   IOSTANDARD LVCMOS33 } [get_ports { dataout[1] }]; #IO_L24P_T3_RS1_15 Sch=led[1]
set_property -dict { PACKAGE_PIN J13   IOSTANDARD LVCMOS33 } [get_ports { dataout[2] }]; #IO_L17N_T2_A25_15 Sch=led[2]
set_property -dict { PACKAGE_PIN N14   IOSTANDARD LVCMOS33 } [get_ports { dataout[3] }]; #IO_L8P_T1_D11_14 Sch=led[3]
set_property -dict { PACKAGE_PIN R18   IOSTANDARD LVCMOS33 } [get_ports { dataout[4] }]; #IO_L7P_T1_D09_14 Sch=led[4]
set_property -dict { PACKAGE_PIN V17   IOSTANDARD LVCMOS33 } [get_ports { dataout[5] }]; #IO_L18N_T2_A11_D27_14 Sch=led[5]
set_property -dict { PACKAGE_PIN U17   IOSTANDARD LVCMOS33 } [get_ports { dataout[6] }]; #IO_L17P_T2_A14_D30_14 Sch=led[6]
set_property -dict { PACKAGE_PIN U16   IOSTANDARD LVCMOS33 } [get_ports { dataout[7] }]; #IO_L18P_T2_A12_D28_14 Sch=led[7]
set_property -dict { PACKAGE_PIN T15   IOSTANDARD LVCMOS33 } [get_ports { key[0] }]; #IO_L14N_T2_SRCC_14 Sch=led[9]
set_property -dict { PACKAGE_PIN U14   IOSTANDARD LVCMOS33 } [get_ports { key[1] }]; #IO_L22P_T3_A05_D21_14 Sch=led[10]
set_property -dict { PACKAGE_PIN T16   IOSTANDARD LVCMOS33 } [get_ports { key[2] }]; #IO_L15N_T2_DQS_DOUT_CSO_B_14 Sch=led[11]
set_property -dict { PACKAGE_PIN V15   IOSTANDARD LVCMOS33 } [get_ports { key[3] }]; #IO_L16P_T2_CSI_B_14 Sch=led[12]
set_property -dict { PACKAGE_PIN V14   IOSTANDARD LVCMOS33 } [get_ports { key[4] }]; #IO_L22N_T3_A04_D20_14 Sch=led[13]
set_property -dict { PACKAGE_PIN V12   IOSTANDARD LVCMOS33 } [get_ports { key[5] }]; #IO_L20N_T3_A07_D23_14 Sch=led[14]
set_property -dict { PACKAGE_PIN V11   IOSTANDARD LVCMOS33 } [get_ports { ready }]; #IO_L21N_T3_DQS_A06_D22_14 Sch=led[15]
```

使用vivado对代码进行综合并生成比特流，烧录进开发板：

![image-20240312164308240](/home/cx_li/.var/app/io.typora.Typora/config/Typora/typora-user-images/image-20240312164308240.png)

烧录之后在开发板上进行实验验证：

刚开机时输出0:

![a0673fe540ee9b661e55986c9165379c](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/02/a0673fe540ee9b661e55986c9165379c.jpg)

以全0作为输入：

![4ab02ba83b302a6da26cdb2808a1d7aa](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/02/4ab02ba83b302a6da26cdb2808a1d7aa.jpg)

ready点亮，得到加密结果：

![9b9ff8196586d53cab3fae5dd4e5d77e](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/02/9b9ff8196586d53cab3fae5dd4e5d77e.jpg)

输入加密结果：

![93198b072b9bdb960b3c100d7cb16565](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/02/93198b072b9bdb960b3c100d7cb16565.jpg)

运行若干个时钟，ready点亮，解密得到加密前的输入：

![a4b937fdd0a6d968ee85ff044e076d1f](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/02/a4b937fdd0a6d968ee85ff044e076d1f.jpg)

可见开发板可以按照预期工作，即，可以正常加解密

### 错误现象及分析

最初没有给寄存器设置初值导致仿真报x。

## 3. 32 位 ALU

### 整体设计

通过将若干个模块，如加法器和与门阵列、或门阵列多路选选择器相连实现按照ALUctr信号输出想要的结果。

### 模块设计

该设计由若干个模块组成：

1. `chose8to1_1` 模块：这是一个8到1的多路选择器，根据选择信号 `chose_sig` 的值，从8个输入信号 `I0` 到 `I7` 中选择一个输出到 `OUT`。
2. `chose8to1` 模块：这个模块内部实例化了 `chose8to1_1` 模块7次，用于处理4位的输入 `I0` 到 `I7`，并将结果输出到 `OUT`。
3. `decoder_seg` 模块：这是一个七段显示解码器，将4位的输入 `I` 解码为8位的输出 `seg`，用于驱动七段显示器的各个段，显示数字0到9以及字母A到F。
4. `decoder_3to8` 模块：这是一个3到8的解码器，将3位的输入 `INPUT` 解码为8位的输出 `OUT`，用于选择七段显示器的一个段。
5. `display` 模块：这个模块用于控制一个七段显示器，它接收时钟信号 `clk` 和8位的数据输入 `DATA0` 到 `DATA7`，以及一个用于选择当前显示位的 `points` 输入，输出到七段显示器的 `SEG` 和选择信号 `choseLED`。
6. `blinker` 模块：这个模块用于控制一个闪烁器，它接收时钟信号 `clk` 和一个用于选择闪烁位的 `blinker_addr` 输入，以及8位的数据输入 `DATA0` 到 `DATA7`，输出到 `OUT_DATA0` 到 `OUT_DATA7`。
7. `trans_1224` 模块：这个模块用于将24小时制的时间转换为12小时制，同时处理上午和下午的显示，以及将时间转换为七段显示器所需的格式。
8. `clock` 模块：这是一个时钟模块，用于模拟时钟的运行，包括小时 `H`、分钟 `M`、秒 `S` 和毫秒 `tms` 的计数，以及用于设置和显示的控制信号。
9. `BCD2INT` 模块：这个模块将BCD编码的小时和分钟转换为整数，用于内部时间的计算和比较。
10. `alarm` 模块：这是一个闹钟模块，用于设置和显示多个闹钟时间，以及控制闹钟的闪烁指示。
11. `stopwatch` 模块：这是一个秒表模块，用于计时，包括开始、停止和重置功能。
12. `time_m` 模块：这个模块用于计算两个时间点之间的差值，输出小时 `cH`、分钟 `cM` 和秒 `cS`。
13. `timers` 模块：这是一个多功能定时器模块。
14. `DigitalTimer` 模块：这是顶层模块，它将上述所有模块整合在一起，实现了数字定时器的所有功能，包括时间显示、闹钟设置、秒表计时等。它接收外部输入信号，如时钟 `clk`、复位 `RST`、开始/暂停 `StartOrPause`、读取参数 `ReadPara`、时间格式 `TimeFormat`、模式选择 `mode`、闹钟编号 `AlarmNo`、高位和低位数据 `data_h` 和 `data_l`，输出包括下午指示 `Afternoon`、整点报时 `TimeKeeper`、闹钟显示 `AlarmDisplay`、七段显示 `segs` 和阳极选择信号 `an`。

模块间链接方式如图：

![dfdee4baf5d9e947eda22b4d20482555](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/dfdee4baf5d9e947eda22b4d20482555.jpg)

代码如下：

``` verilog
`timescale 1ns / 1ps

`define seg_0 (~I[0]&~I[1]&~I[2]&~I[3])
`define seg_1 (~I[0]&~I[1]&~I[2]&I[3])
`define seg_2 (~I[0]&~I[1]&I[2]&~I[3])
`define seg_3 (~I[0]&~I[1]&I[2]&I[3])
`define seg_4 (~I[0]&I[1]&~I[2]&~I[3])
`define seg_5 (~I[0]&I[1]&~I[2]&I[3])
`define seg_6 (~I[0]&I[1]&I[2]&~I[3])
`define seg_7 (~I[0]&I[1]&I[2]&I[3])
`define seg_8 (I[0]&~I[1]&~I[2]&~I[3])
`define seg_9 (I[0]&~I[1]&~I[2]&I[3])
`define seg_A (I[0]&~I[1]&I[2]&~I[3])
`define seg_B (I[0]&~I[1]&I[2]&I[3])
`define seg_C (I[0]&I[1]&~I[2]&~I[3])
`define seg_D (I[0]&I[1]&~I[2]&I[3])
`define seg_E (I[0]&I[1]&I[2]&~I[3])
`define seg_F (I[0]&I[1]&I[2]&I[3])

module chose8to1_1(
        input I0,
        input I1,
        input I2,
        input I3,
        input I4,
        input I5,
        input I6,
        input I7,
        output OUT,
        input [2:0] chose_sig
    );
    assign OUT = (chose_sig == 0 & I0) |
            (chose_sig == 1 & I1) | 
            (chose_sig == 2 & I2) | 
            (chose_sig == 3 & I3) | 
            (chose_sig == 4 & I4) | 
            (chose_sig == 5 & I5) | 
            (chose_sig == 6 & I6) | 
            (chose_sig == 7 & I7);
endmodule
module chose8to1(
        input [3:0] I0,
        input [3:0] I1,
        input [3:0] I2,
        input [3:0] I3,
        input [3:0] I4,
        input [3:0] I5,
        input [3:0] I6,
        input [3:0] I7,
        output [3:0] OUT,
        input [2:0] C
    );
    genvar i;
    generate
        for(i = 0; i <= 3; i = i + 1)begin
            chose8to1_1 chose_blk(
                .I0(I0[i]),
                .I1(I1[i]),
                .I2(I2[i]),
                .I3(I3[i]),
                .I4(I4[i]),
                .I5(I5[i]),
                .I6(I6[i]),
                .I7(I7[i]),
                .OUT(OUT[3 - i]),
                .chose_sig(C)
            );
        end
    endgenerate
endmodule
// set F to blank
module decoder_seg(
                input [3:0] I,
                input point,
                output [7:0] seg
            );
    assign seg[0] = `seg_1 | `seg_4 | `seg_B | `seg_D | `seg_F;
    assign seg[1] = `seg_5 | `seg_6 | `seg_B | `seg_C | `seg_E | `seg_F;
    assign seg[2] = `seg_2 | `seg_C | `seg_E | `seg_F;
    assign seg[3] = `seg_1 | `seg_4 | `seg_7 | `seg_A | `seg_F;
    assign seg[4] = `seg_1 | `seg_3 | `seg_4 | `seg_5 | `seg_7 | `seg_9 | `seg_F;
    assign seg[5] = `seg_1 | `seg_2 | `seg_3 | `seg_7 | `seg_D | `seg_F;
    assign seg[6] = `seg_0 | `seg_1 | `seg_7 | `seg_C | `seg_F;
    assign seg[7] = point;
endmodule

module decoder_3to8(
            input [2:0] INPUT,
            output [7:0] OUT
        );
    wire [3:0] I;
    assign I = {INPUT[0], INPUT[1], INPUT[2], 1'b0};
    assign OUT[0] = ~`seg_0;
    assign OUT[1] = ~`seg_1;
    assign OUT[2] = ~`seg_2;
    assign OUT[3] = ~`seg_3;
    assign OUT[4] = ~`seg_4;
    assign OUT[5] = ~`seg_5;
    assign OUT[6] = ~`seg_6;
    assign OUT[7] = ~`seg_7;
endmodule

module display(
    input clk,
    input [3:0]DATA0,
    input [3:0]DATA1,
    input [3:0]DATA2,
    input [3:0]DATA3,
    input [3:0]DATA4,
    input [3:0]DATA5,
    input [3:0]DATA6,
    input [3:0]DATA7,
    input [7:0]points,
    output [7:0] SEG,
    output [7:0] choseLED
);
    wire [3:0]BUS;
    wire [2:0]choseLED_W;
    reg [2:0]c_REG;
    wire [2:0]CREG_w;
    assign CREG_w = c_REG;
    chose8to1 OUT_SUB(
        .I0(DATA0),
        .I1(DATA1),
        .I2(DATA2),
        .I3(DATA3),
        .I4(DATA4),
        .I5(DATA5),
        .I6(DATA6),
        .I7(DATA7),
        .OUT(BUS),
        .C(CREG_w)
    );
    decoder_3to8 C_LED( 
        .INPUT(3'b111 - CREG_w),
        .OUT(choseLED)
    );
    decoder_seg num2seg(
        .I(BUS),
        .point(points[3'b111 - CREG_w]),
        .seg(SEG)
    );
    reg [31:0] counter = 31'd0;
    always@(posedge clk) begin : main
        counter <= counter + 1;
        c_REG <= (counter/10000) % 8;
        if(counter == 100000000)begin
           counter <= 0;
        end
    end
endmodule

module blinker(
    input clk,
    input [7:0]blinker_addr,
    input [3:0]DATA0,
    input [3:0]DATA1,
    input [3:0]DATA2,
    input [3:0]DATA3,
    input [3:0]DATA4,
    input [3:0]DATA5,
    input [3:0]DATA6,
    input [3:0]DATA7,
    output [3:0]OUT_DATA0,
    output [3:0]OUT_DATA1,
    output [3:0]OUT_DATA2,
    output [3:0]OUT_DATA3,
    output [3:0]OUT_DATA4,
    output [3:0]OUT_DATA5,
    output [3:0]OUT_DATA6,
    output [3:0]OUT_DATA7
);
    reg [31:0]cnt = 0;
    assign OUT_DATA0 = (blinker_addr[7] == 1 && cnt > 50000000) ? 4'b1111 : DATA0;
    assign OUT_DATA1 = (blinker_addr[6] == 1 && cnt > 50000000) ? 4'b1111 : DATA1;
    assign OUT_DATA2 = (blinker_addr[5] == 1 && cnt > 50000000) ? 4'b1111 : DATA2;
    assign OUT_DATA3 = (blinker_addr[4] == 1 && cnt > 50000000) ? 4'b1111 : DATA3;
    assign OUT_DATA4 = (blinker_addr[3] == 1 && cnt > 50000000) ? 4'b1111 : DATA4;
    assign OUT_DATA5 = (blinker_addr[2] == 1 && cnt > 50000000) ? 4'b1111 : DATA5;
    assign OUT_DATA6 = (blinker_addr[1] == 1 && cnt > 50000000) ? 4'b1111 : DATA6;
    assign OUT_DATA7 = (blinker_addr[0] == 1 && cnt > 50000000) ? 4'b1111 : DATA7;
    always @(posedge clk) begin
        cnt <= (cnt + 1) % 100000000;
    end
endmodule

module trans_1224(
    input is_12,
    input [6:0]H,
    input [6:0]M,
    input [6:0]S,
    input [6:0]ms,
    output afternoon_led,
    output [3:0]DATA0,
    output [3:0]DATA1,
    output [3:0]DATA2,
    output [3:0]DATA3,
    output [3:0]DATA4,
    output [3:0]DATA5,
    output [3:0]DATA6,
    output [3:0]DATA7,
    output [7:0]points
);
    wire [6:0]H_1224;
    assign afternoon_led = (is_12 == 1'b1 && H > 12) ? 1 : 0;
    assign H_1224 = (is_12 == 1'b1 && H > 12) ? H - 12 : H;
    assign DATA0 = H_1224/10;
    assign DATA1 = H_1224%10;
    assign DATA2 = M/10;
    assign DATA3 = M%10;
    assign DATA4 = S/10;
    assign DATA5 = S%10;
    assign DATA6 = ms/10;
    assign DATA7 = ms%10;
    assign points = 8'b10101011;
endmodule

module clock(
    input clk,
    input [6:0]setting_num,
    input set,
    input [1:0]setting_mode,
    input enable,
    output [6:0]H,
    output [6:0]M,
    output [6:0]S,
    output [6:0]tms,
    output [7:0]blink_chose,
    output [2:0]TimeKeeper
);
    reg [31:0]counter;
    reg [6:0]rS = 0;
    reg [6:0]rM = 0;
    reg [6:0]rH = 0;
    reg [6:0]rTMS = 0;
    reg [7:0]blink_r;
    reg [2:0]TimeKeeper_R;
    assign TimeKeeper = TimeKeeper_R;
    assign tms = rTMS;
    assign S = rS;
    assign M = rM;
    assign H = rH;
    assign blink_chose = blink_r;
    reg is_setting = 0, has_setted = 0;
    always @(posedge clk) begin
        if(((setting_mode == 2'b00 || has_setted == 1) && is_setting == 0) || enable == 0)begin
            TimeKeeper_R = (rM == 0 && (rS == 0 || rS == 2 || rS == 4 || rS == 6 || rS == 8)) ? 4'b1111 : 4'b0000;
            if(setting_mode == 2'b00)begin
                has_setted <= 0;
            end
            if(counter == 999999)begin
                counter <= 0;
                if(rTMS == 99)begin
                    if(rS == 59)begin
                        if(rM == 59)begin
                            rH = (rH + 1) % 24;
                        end
                        rM = (rM + 1) % 60;
                    end
                    rS = (rS + 1) % 60;
                end
                rTMS <= (rTMS + 1) % 100;
            end else begin
                counter <= counter + 1;
            end
        end
        else begin
            if(has_setted == 0)begin
                is_setting <= 1;
            end
            if(set == 1)begin
                blink_r <= 8'b00000000;
                has_setted = 1;
                is_setting = 0;
            end
            if(setting_mode == 2'b01 && has_setted == 0)begin
                blink_r <= 8'b00001100;
                rS <= setting_num % 60;//(setting_num > 7'd59) ? 59 : setting_num;
            end
            if(setting_mode == 2'b10 & has_setted == 0)begin
                blink_r <= 8'b00110000;
                rM <= setting_num % 60;//(setting_num > 7'd59) ? 59 : setting_num;
            end
            if(setting_mode == 2'b11 && has_setted == 0)begin
                blink_r <= 8'b11000000;
                rH <= setting_num % 24;//(setting_num > 7'd23) ? 23 : setting_num;
            end
            if(setting_mode == 2'b00 && has_setted == 0)begin
                blink_r <= 8'b11111111;
            end
        end
    end
endmodule

module BCD2INT(
    input [3:0] data_h,//���ò�����λ��ʹ�� BCD ���ʾ
    input [3:0] data_l,//���ò�����λ��ʹ�� BCD ���ʾ
    output [6:0] data_out
);
    assign data_out = 10 * ((data_h > 9) ? 9 : data_h) + ((data_l > 9) ? 9 : data_l);
endmodule

module alarm(
    input clk,
    input [6:0]now_H,
    input [6:0]now_M,
    input [6:0]now_S,
    input [6:0]setting_num,
    input enable,
    input [1:0]AlarmNo,
    input set,
    input [1:0]setting_mode,
    output [6:0]setted_H,
    output [6:0]setted_M,
    output [6:0]setted_S,
    output [7:0]blink_chose,
    output [2:0]AlarmDisplay
);
    reg [6:0]alram_H[0:3];
    reg [6:0]alram_M[0:3];
    reg [6:0]alram_S[0:3];
    reg [2:0]alram_LED;
    reg [31:0]alram_start = 0;
    reg is_alraming, red_LED;
    reg [7:0]blink_r;
    assign blink_chose = blink_r;
    assign AlarmDisplay = alram_LED;
    assign setted_H = alram_H[AlarmNo];
    assign setted_M = alram_M[AlarmNo];
    assign setted_S = alram_S[AlarmNo];
    wire at_time;
    assign AlarmDisplay[0] = red_LED;
    assign at_time =
                 ((now_H == alram_H[0] && now_M == alram_M[0] && now_S == alram_S[0]) || 
                 (now_H == alram_H[1] && now_M == alram_M[1] && now_S == alram_S[1]) || 
                 (now_H == alram_H[2] && now_M == alram_M[2] && now_S == alram_S[2]) || 
                 (now_H == alram_H[3] && now_M == alram_M[3] && now_S == alram_S[3])  == 1 )? 1 : 0;
    reg has_setted, is_setting;
    always@(posedge clk)begin
        
        if(is_alraming == 0)begin
            is_alraming <= at_time;
            alram_start <= (at_time == 1) ? 0 : 100000000;
        end
        if(is_alraming == 1)begin
            alram_start <= alram_start + 1;
        end
        red_LED <= ((alram_start / 100000000) % 2 == 0) ? 1 : 0;
        if(alram_start >= 1000000000)begin
            is_alraming <= 0;
            alram_start <= 100000000;
            red_LED <= 0;
        end
        
        if(enable == 1)begin
            if(setting_mode == 2'b00 && has_setted == 1)begin
                has_setted <= 0;
            end
            if(setting_mode != 2'b00 && has_setted == 0)begin
                is_setting <= 1;
            end
            if(is_setting == 1)begin
                if(set == 1)begin
                    blink_r <= 8'b00000000;
                    has_setted = 1;
                    is_setting = 0;
                end
                if(setting_mode == 2'b01 && has_setted == 0)begin
                    blink_r <= 8'b00001100;
                    alram_S[AlarmNo] <= setting_num % 60;//(setting_num > 7'd59) ? 59 : setting_num;
                end
                if(setting_mode == 2'b10 & has_setted == 0)begin
                    blink_r <= 8'b00110000;
                    alram_M[AlarmNo] <= setting_num % 60;//(setting_num > 7'd59) ? 59 : setting_num;
                end
                if(setting_mode == 2'b11 && has_setted == 0)begin
                    blink_r <= 8'b11000000;
                    alram_H[AlarmNo] <= setting_num % 24;//(setting_num > 7'd23) ? 23 : setting_num;
                end
                if(setting_mode == 2'b00 && has_setted == 0)begin
                    blink_r <= 8'b11111111;
                end
            end
        end
    end
endmodule

module stopwatch(
    input srart_stop,
    input reset,
    input enable,
    input clk,
    output [6:0]H,
    output [6:0]M,
    output [6:0]S,
    output [6:0]tms,
    output [7:0]blink_chose
);
    assign blink_chose = 8'b00000000;
    reg [63:0]counter = 0;
    reg is_stop = 1;
    reg is_pushdown = 0;
    reg is_rst_pushdown = 0;
    reg [6:0]rS = 0;
    reg [6:0]rM = 0;
    reg [6:0]rH = 0;
    reg [6:0]rTMS = 0;
    assign H = rH;
    assign M = rM;
    assign S = rS;
    assign tms = rTMS;
    always@(posedge clk)begin
        if(enable == 1)begin
            if(srart_stop == 1 && is_pushdown == 0)begin
                is_stop = ~is_stop;
                is_pushdown <= 1;
            end
            if(reset == 1 && is_rst_pushdown == 0)begin
                counter <= 0;
                rTMS <= 0;
                rS <= 0;
                rM <= 0;
                rH <= 0;
                is_rst_pushdown <= 1;
            end
        end
        if(srart_stop == 0)begin
            is_pushdown <= 0;
        end
        if(reset == 0)begin
            is_rst_pushdown <= 0;
        end
        if(is_stop == 0 && !(reset == 1 && is_rst_pushdown == 0))begin
            counter <= counter + 1;//1s = 100000000
            if(counter == 999999)begin
                counter <= 0;
                if(rTMS == 99)begin
                    if(rS == 59)begin
                        if(rM == 59)begin
                            rH = (rH + 1) % 24;
                        end
                        rM = (rM + 1) % 60;
                    end
                    rS = (rS + 1) % 60;
                end
                rTMS <= (rTMS + 1) % 100;
            end else begin
                counter <= counter + 1;
            end
        end
    end
endmodule

//a - b
module time_m(
    input [6:0]aH,
    input [6:0]aM,
    input [6:0]aS,
    input [6:0]bH,
    input [6:0]bM,
    input [6:0]bS,
    output [6:0]cH,
    output [6:0]cM,
    output [6:0]cS
);
    wire S2M, M2H;
    assign S2M = (aS >= bS) ? 0 : 1;
    assign M2H = (aM >= (bM + S2M)) ? 0 : 1;
    assign cS = (aS >= bS) ? (aS - bS) : (aS + 60 - bS);
    assign cM = (M2H) ? (aM + 60 - (bM + S2M)) : (aM - (bM + S2M));
    assign cH = aH - (bH + M2H);
endmodule

module timers(
    input clk,
    input [1:0]setting_mode,
    input [6:0]setting_num,
    input start_stop,
    input enable,
    input reset,
    input set,
    output [7:0]blink_chose,
    output [6:0]H,
    output [6:0]M,
    output [6:0]S,
    output [6:0]tms,
    output red_LED
);
    reg [6:0] max_H = 0;
    reg [6:0] max_M = 1;
    reg [6:0] max_S = 0;
    reg [6:0] rH = 0;
    reg [6:0] rM = 0;
    reg [6:0] rS = 0;
    reg [6:0] rTMS;
    reg is_setting = 0, has_setted = 0, is_running = 1, is_stop = 1;
    reg has_pushdown_stop = 0;
    reg [63:0] counter = 0;
    reg [63:0] tms_counter = 0;
    reg alram_LED = 0;
    assign red_LED = alram_LED;
    reg [7:0]blink_r;
    assign blink_chose = blink_r;
    time_m res(
        .aH(max_H),
        .aM(max_M),
        .aS(max_S),
        .bH(rH),
        .bM(rM),
        .bS(rS),
        .cH(H),
        .cM(M),
        .cS(S)
    );
    assign tms = (99 - rTMS);
    reg is_stop_pushdown = 0, is_rst_pushdown = 1;
    always@(posedge clk)begin
        if(is_running == 0)begin
            rTMS <= 99;
            rH <= 0;
            rM <= 0;
            rS <= 0;
            if(enable == 1)begin
                if(set == 1)begin
                    blink_r <= 8'b00000000;
                    has_setted <= 1;
                    is_running <= 1;
                    is_stop <= 1;
                end
                if(setting_mode == 2'b01 && has_setted == 0)begin
                    blink_r <= 8'b00001100;
                    max_S <= setting_num % 60;//(setting_num > 7'd59) ? 59 : setting_num;
                end
                if(setting_mode == 2'b10 & has_setted == 0)begin
                    blink_r <= 8'b00110000;
                    max_M <= setting_num % 60;//(setting_num > 7'd59) ? 59 : setting_num;
                end
                if(setting_mode == 2'b11 && has_setted == 0)begin
                    blink_r <= 8'b11000000;
                    max_H <= setting_num % 24;//(setting_num > 7'd23) ? 23 : setting_num;
                end
                if(setting_mode == 2'b00 && has_setted == 0)begin
                    blink_r <= 8'b11111111;
                end
            end
        end
        if(is_running == 1)begin
            blink_r <= 8'b00000000;
            if(enable == 1)begin
                if(setting_mode != 2'b00 && has_setted == 0)begin
                    is_running <= 0;
                end
                if(setting_mode != 2'b00 && has_setted == 1)begin
                    is_running <= 1;
                end
                if(setting_mode == 0)begin
                    has_setted <= 0;
                end
            end
            if(max_H == rH && max_M == rM && max_S == rS && rTMS == 99)begin
                rTMS <= 99;
                if(counter == 199999999)begin
                    counter <= 0;
                end else begin
                    counter <= counter + 1;
                end
                if(is_stop == 0)begin
                    alram_LED <= (counter / 100000000) % 2;
                end
                else begin
                    alram_LED <= 0;
                end
                if(enable == 1)begin
                    if(reset == 1 && is_rst_pushdown == 0)begin
                        counter <= 0;
                        rTMS <= 99;
                        rS <= 0;
                        rM <= 0;
                        rH <= 0;
                        is_rst_pushdown <= 1;
                        is_stop <= 1;
                    end
                    if(reset == 0)begin
                        is_rst_pushdown <= 0;
                    end
                end
            end else begin
                alram_LED <= 0;
                if(enable == 1)begin
                    if(start_stop == 1 && is_stop_pushdown == 0)begin
                        is_stop = ~is_stop;
                        is_stop_pushdown <= 1;
                    end
                    if(start_stop == 0)begin
                        is_stop_pushdown <= 0;
                    end
                    if(reset == 1 && is_rst_pushdown == 0)begin
                        counter <= 0;
                        rTMS <= 99;
                        rS <= 0;
                        rM <= 0;
                        rH <= 0;
                        is_rst_pushdown <= 1;
                    end
                    if(reset == 0)begin
                        is_rst_pushdown <= 0;
                    end
                end
                if(is_stop == 0)begin
                    counter <= counter + 1;//1s = 100000000
                    if(counter == 999999)begin
                        counter <= 0;
                        if(rTMS == 99)begin
                            if(rS == 59)begin
                                if(rM == 59)begin
                                    rH = (rH + 1) % 24;
                                end
                                rM = (rM + 1) % 60;
                            end
                            rS = (rS + 1) % 60;
                        end
                        rTMS <= (rTMS + 1) % 100;
                    end else begin
                        counter <= counter + 1;
                    end
                end
            end
        end
    end
endmodule

module DigitalTimer (
    input clk,//���ӵ�ʱ�Ӷ˿� CLK100MHZ������ E3
    input RST,//��λ��ť��������Ч
    input StartOrPause,//��ʱ����ʼ����ͣ������ 1 �ο�ʼ���ٰ� 1 ����ͣ
    input ReadPara,//��ȡ���������������ý����󣬵��� 1 �Σ���ȡ����
    input TimeFormat,//=0 ��ʾ 24 Сʱ�ƣ�=1 ��ʾ 12 Сʱ��
    input [1:0] mode,//����ѡ��00 ����ʱ�ӣ�01 ����ʱ��10 ��ʱ����11 ��������
    input [1:0] ParaSelect,// �������ã�00 �ޣ�01 ����������10 ���÷��ӣ�11 ����Сʱ
    input [1:0] AlarmNo,// ������ţ�0~3
    input [3:0] data_h,//���ò�����λ��ʹ�� BCD ���ʾ
    input [3:0] data_l,//���ò�����λ��ʹ�� BCD ���ʾ
    output Afternoon,//12 Сʱ��ʱ������ʱ�����Ϊ 1
    output [2:0] TimeKeeper,//������� 3 ɫָʾ��
    output [2:0] AlarmDisplay,//������� 3 ɫָʾ��
    output [7:0] segs,//�߶����������ֵ����ʾ����
    output [7:0] an//�߶�����ܿ���λ������ʱ���֡���
);
// Add your code
    wire [6:0] display_BUS_time_H [0:3];
    wire [6:0] display_BUS_time_M [0:3];
    wire [6:0] display_BUS_time_S [0:3]; 
    wire [6:0] display_BUS_time_tMS [0:3];
    wire [7:0]blink_BUS [0:3];
    wire [6:0]data_BUS;
    wire enable [0:3];
    assign enable[0] = (mode == 2'b00) ? 1 : 0;
    assign enable[1] = (mode == 2'b01) ? 1 : 0;
    assign enable[2] = (mode == 2'b10) ? 1 : 0;
    assign enable[3] = (mode == 2'b11) ? 1 : 0;
    BCD2INT BCD2INT0(
        .data_h(data_h),
        .data_l(data_l),
        .data_out(data_BUS)
    );

    clock clock0( 
        .clk(clk),
        .setting_num(data_BUS),
        .set(ReadPara),
        .setting_mode(ParaSelect),
        .enable(enable[0]),
        .H(display_BUS_time_H[0]),
        .M(display_BUS_time_M[0]),
        .S(display_BUS_time_S[0]),
        .tms(display_BUS_time_tMS[0]),
        .blink_chose(blink_BUS[0]),
        .TimeKeeper(TimeKeeper)
    );
    alarm alarm0(
        .clk(clk),
        .now_H(display_BUS_time_H[0]),
        .now_M(display_BUS_time_M[0]),
        .now_S(display_BUS_time_S[0]),
        .setting_num(data_BUS),
        .enable(enable[3]),
        .AlarmNo(AlarmNo),
        .set(ReadPara),
        .setting_mode(ParaSelect),
        .setted_H(display_BUS_time_H[3]),
        .setted_M(display_BUS_time_M[3]),
        .setted_S(display_BUS_time_S[3]),
        .blink_chose(blink_BUS[3]),
        .AlarmDisplay(AlarmDisplay)
    );
    stopwatch stopwatch0(
        .srart_stop(StartOrPause),
        .reset(RST),
        .enable(enable[2]),
        .clk(clk),
        .H(display_BUS_time_H[2]),
        .M(display_BUS_time_M[2]),
        .S(display_BUS_time_S[2]),
        .tms(display_BUS_time_tMS[2]),
        .blink_chose(blink_BUS[2])
    );
    timers timer0(
        .clk(clk),
        .setting_mode(ParaSelect),
        .setting_num(data_BUS),
        .start_stop(StartOrPause),
        .enable(enable[1]),
        .reset(RST),
        .set(ReadPara),
        .blink_chose(blink_BUS[1]),
        .H(display_BUS_time_H[1]),
        .M(display_BUS_time_M[1]),
        .S(display_BUS_time_S[1]),
        .tms(display_BUS_time_tMS[1]),
        .red_LED(AlarmDisplay[1])
    );

    wire [3:0]trans2blinker_0;
    wire [3:0]trans2blinker_1; 
    wire [3:0]trans2blinker_2; 
    wire [3:0]trans2blinker_3; 
    wire [3:0]trans2blinker_4;
    wire [3:0]trans2blinker_5;
    wire [3:0]trans2blinker_6;
    wire [3:0]trans2blinker_7;
    wire [7:0]trans2display_point;
    trans_1224 trans_1224_0(
        .is_12(TimeFormat),
        .H(display_BUS_time_H[mode]),
        .M(display_BUS_time_M[mode]),
        .S(display_BUS_time_S[mode]),
        .ms(display_BUS_time_tMS[mode]),
        .afternoon_led(Afternoon),
        .DATA0(trans2blinker_0),
        .DATA1(trans2blinker_1),
        .DATA2(trans2blinker_2),
        .DATA3(trans2blinker_3),
        .DATA4(trans2blinker_4),
        .DATA5(trans2blinker_5),
        .DATA6(trans2blinker_6),
        .DATA7(trans2blinker_7),
        .points(trans2display_point)
    );
    wire [3:0]blinker2display_0;
    wire [3:0]blinker2display_1; 
    wire [3:0]blinker2display_2;
    wire [3:0]blinker2display_3; 
    wire [3:0]blinker2display_4;
    wire [3:0]blinker2display_5;
    wire [3:0]blinker2display_6;
    wire [3:0]blinker2display_7;
    blinker blinker0(
        .clk(clk),
        .blinker_addr(blink_BUS[mode]),
        .DATA0(trans2blinker_0),
        .DATA1(trans2blinker_1),
        .DATA2(trans2blinker_2),
        .DATA3(trans2blinker_3),
        .DATA4(trans2blinker_4),
        .DATA5(trans2blinker_5),
        .DATA6(trans2blinker_6),
        .DATA7(trans2blinker_7),
        .OUT_DATA0(blinker2display_0),
        .OUT_DATA1(blinker2display_1),
        .OUT_DATA2(blinker2display_2),
        .OUT_DATA3(blinker2display_3),
        .OUT_DATA4(blinker2display_4),
        .OUT_DATA5(blinker2display_5),
        .OUT_DATA6(blinker2display_6),
        .OUT_DATA7(blinker2display_7)
    );
    display display0(
        .clk(clk),
        .DATA0(blinker2display_0),
        .DATA1(blinker2display_1),
        .DATA2(blinker2display_2),
        .DATA3(blinker2display_3),
        .DATA4(blinker2display_4),
        .DATA5(blinker2display_5),
        .DATA6(blinker2display_6),
        .DATA7(blinker2display_7),
        .points(trans2display_point),
        .SEG(segs),
        .choseLED(an)
        );

endmodule


```

其中译码器和分配器使用的是与上一个实验完全相同的模块，故不再赘述。

### 仿真

由于功能过于复杂，不进行仿真而直接烧录FPGA进行验证。

### 验证

使用框架提供的约束文件：

```verilog
set_property -dict { PACKAGE_PIN E3    IOSTANDARD LVCMOS33 } [get_ports { clk }]; #IO_L12P_T1_MRCC_35 Sch=clk100mhz
```

使用vivado对代码进行综合并生成比特流，烧录进开发板：

![image-20240312212658399](/home/cx_li/.var/app/io.typora.Typora/config/Typora/typora-user-images/image-20240312212658399.png)

烧入开发板后时钟如此工作：



可见开发板可以按照预期工作。

秒表：![5e31f0b6a3194d4d577383c257a948f3](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/03/5e31f0b6a3194d4d577383c257a948f3.jpg)

![9c6ce8190202c8616b9eb5979357ff9e](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/03/9c6ce8190202c8616b9eb5979357ff9e.jpg)

倒计时结束闪烁绿灯：![52e963c7bf1fed9674983257534ce926](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/03/52e963c7bf1fed9674983257534ce926.jpg)

闹钟设置（没有亮的位置正在闪烁，表示正在设置的位置）：![274cf691af98123fdc0cf9b9131ebef9](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/03/274cf691af98123fdc0cf9b9131ebef9.jpg)

12小时制：![693ff60fb8e60997a8a91c94daa6f049](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/03/693ff60fb8e60997a8a91c94daa6f049.jpg)

完成设置，等待按下set后开始运行：![b1ad3c8dc49f3d1c4ae99ed80db09fe9](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/03/b1ad3c8dc49f3d1c4ae99ed80db09fe9.jpg)

闹钟闪烁![b9613e63f2f7148f928b76e2588fc259](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/03/b9613e63f2f7148f928b76e2588fc259.jpg)

整点闪烁：![c21d35a70b24b07ef15ed2438f92470f](/home/cx_li/文档/GitHub/digitalLogic_Lab/digital_logic_exp/lab2/photo/03/c21d35a70b24b07ef15ed2438f92470f.jpg)

### 错误现象及分析

实验中没有遇到错误。

---

## 思考题

### 1.分析 32 位 ALU 的资源占用情况。

分析如下：![image-20240312224013112](/home/cx_li/.var/app/io.typora.Typora/config/Typora/typora-user-images/image-20240312224013112.png)

该寄存器占用资源很少，只有不超过0.5%的逻辑片资源站占用。

### 2. 分析 64 位移位寄存器的时序性能和资源占用情况；并通过资料查找到其他的生成 LFSR 的反馈公式

时序性能分析如下：

![截图 2024-03-17 20-15-49](/home/cx_li/图片/截图/截图 2024-03-17 20-15-49.png)

没有出现时序问题。

资源占用情况如下：

![image-20240317201915544](/home/cx_li/.var/app/io.typora.Typora/config/Typora/typora-user-images/image-20240317201915544.png)

可见占用较少。

k位LFSR的反馈公式为：
$$
new\ x_i = \left \{
\begin{aligned}
&\left (\sum_{i=0}^{k-1}a_ix_i\right )\mod 2,(\forall i\in [0,k-1]\cap N, a_i\in \{0,1\}), &i = k-1\\
& x_{i+1},& i \not= k-1
\end{aligned}
\right .
$$
此处模2加法等价与异或。

### 3. 数字时钟中是如何实现倒计时和毫秒计时器功能？

毫秒级计时器中有两个寄存器分别记录毫秒数和时钟数，当时钟数寄存器等于（时钟赫兹数*赫兹/1000 - 1）时下一个周期时钟数寄存器归零而毫秒数寄存器加一。从而实现了毫秒级的计时功能。

倒计时中，维护一个上述实现的按照毫秒数寄存器，然后显示的数字是目标时长的毫秒数减去毫秒数寄存器的值，通过差值是否为0判断是否到时间，从而可以实现倒计时。

### 4. 如何实现寄存器堆中 0 号寄存器的值始终为零？

在verilog中进行判断：判断写选择是否是0号，是的话就写入0否则写入写总线上的值即可实现寄存器堆中 0 号寄存器的值始终为零。
